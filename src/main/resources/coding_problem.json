[
        {
                "title": "Right-Angled Triangle Pattern",
                "description": "Given an integer n, print a right-angled triangle pattern of '*' with n rows.",
                "topic": "Patterns",
                "subtopic": "Basic Pattern Printing",
                "level": "Easy",
                "tags": ["patterns", "loops"],
                "examples": {
                        "example1": "Input: n = 3\nOutput:\n*\n**\n***",
                        "example2": "Input: n = 5\nOutput:\n*\n**\n***\n****\n*****"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 100"
                },
                "hints": {
                        "hint1": "Use nested loops to print rows and columns.",
                        "hint2": "Outer loop controls rows, inner loop controls columns."
                },
                "testCases": {
                        "test1": "Input: 3 | Output:\n*\n**\n***",
                        "test2": "Input: 5 | Output:\n*\n**\n***\n****\n*****"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void printTriangle(int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def printTriangle(self, n: int):\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    void printTriangle(int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Hollow Square Pattern",
                "description": "Given an integer n, print a hollow square pattern of '*' with n rows and n columns.",
                "topic": "Patterns",
                "subtopic": "Loops and Conditions",
                "level": "Medium",
                "tags": ["patterns", "loops", "conditional logic"],
                "examples": {
                        "example1": "Input: n = 4\nOutput:\n****\n*  *\n*  *\n****",
                        "example2": "Input: n = 5\nOutput:\n*****\n*   *\n*   *\n*   *\n*****"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 100"
                },
                "hints": {
                        "hint1": "Print '*' for border cells and ' ' for inner cells.",
                        "hint2": "Use conditions inside the loops to decide what to print."
                },
                "testCases": {
                        "test1": "Input: 4 | Output:\n****\n*  *\n*  *\n****",
                        "test2": "Input: 5 | Output:\n*****\n*   *\n*   *\n*   *\n*****"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void printHollowSquare(int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def printHollowSquare(self, n: int):\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    void printHollowSquare(int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Diamond Pattern",
                "description": "Given an integer n, print a symmetric diamond pattern of '*' with 2n-1 rows.",
                "topic": "Patterns",
                "subtopic": "Centered Shapes",
                "level": "Medium",
                "tags": ["patterns", "loops", "nested loops"],
                "examples": {
                        "example1": "Input: n = 3\nOutput:\n  *\n ***\n*****\n ***\n  *",
                        "example2": "Input: n = 4\nOutput:\n   *\n  ***\n *****\n*******\n *****\n  ***\n   *"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 50"
                },
                "hints": {
                        "hint1": "Print spaces before stars to center the pattern.",
                        "hint2": "Use two loops: one for upper half, one for lower half."
                },
                "testCases": {
                        "test1": "Input: 3 | Output:\n  *\n ***\n*****\n ***\n  *",
                        "test2": "Input: 4 | Output:\n   *\n  ***\n *****\n*******\n *****\n  ***\n   *"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void printDiamond(int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def printDiamond(self, n: int):\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    void printDiamond(int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Pascal's Triangle",
                "description": "Given an integer numRows, generate the first numRows of Pascal’s triangle.",
                "topic": "Patterns",
                "subtopic": "Mathematical Patterns",
                "level": "Medium",
                "tags": ["patterns", "math", "combinatorics"],
                "examples": {
                        "example1": "Input: numRows = 5\nOutput:\n    1\n   1 1\n  1 2 1\n 1 3 3 1\n1 4 6 4 1",
                        "example2": "Input: numRows = 3\nOutput:\n  1\n 1 1\n1 2 1"
                },
                "constraints": {
                        "constraint1": "1 <= numRows <= 30"
                },
                "hints": {
                        "hint1": "Each row’s elements are computed based on the previous row.",
                        "hint2": "Use binomial coefficient properties."
                },
                "testCases": {
                        "test1": "Input: 3 | Output:\n  1\n 1 1\n1 2 1",
                        "test2": "Input: 5 | Output:\n    1\n   1 1\n  1 2 1\n 1 3 3 1\n1 4 6 4 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void generatePascalsTriangle(int numRows) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def generatePascalsTriangle(self, numRows: int):\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    void generatePascalsTriangle(int numRows) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Spiral Matrix",
                "description": "Given an integer n, generate an n x n matrix filled with elements from 1 to n^2 in a spiral order.",
                "topic": "Patterns",
                "subtopic": "Matrix Traversal",
                "level": "Hard",
                "tags": ["patterns", "matrix", "simulation"],
                "examples": {
                        "example1": "Input: n = 3\nOutput:\n1 2 3\n8 9 4\n7 6 5"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 100"
                },
                "hints": {
                        "hint1": "Use direction vectors to simulate movement.",
                        "hint2": "Change direction when reaching a boundary or a filled cell."
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[][] generateMatrix(int n) {\n        // Write your code here\n    }\n}"
                }
        },
        {
                "title": "Butterfly Pattern",
                "description": "Given an integer n, print a butterfly pattern of '*' with 2n rows.",
                "topic": "Patterns",
                "subtopic": "Complex Symmetric Shapes",
                "level": "Hard",
                "tags": ["patterns", "loops", "nested loops"],
                "examples": {
                        "example1": "Input: n = 4\nOutput:\n*      *\n**    **\n***  ***\n********\n********\n***  ***\n**    **\n*      *",
                        "example2": "Input: n = 5\nOutput:\n*        *\n**      **\n***    ***\n****  ****\n**********\n**********\n****  ****\n***    ***\n**      **\n*        *"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 50"
                },
                "hints": {
                        "hint1": "The pattern consists of two symmetric triangles on top and bottom.",
                        "hint2": "Use nested loops to handle spaces and stars separately."
                },
                "testCases": {
                        "test1": "Input: 4 | Output:\n*      *\n**    **\n***  ***\n********\n********\n***  ***\n**    **\n*      *",
                        "test2": "Input: 5 | Output:\n*        *\n**      **\n***    ***\n****  ****\n**********\n**********\n****  ****\n***    ***\n**      **\n*        *"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void printButterfly(int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def printButterfly(self, n: int):\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    void printButterfly(int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Count Digits",
                "description": "Given an integer n, count the number of digits in it.",
                "topic": "Mathematics",
                "subtopic": "Number Theory",
                "level": "Easy",
                "tags": ["math", "digits", "loop"],
                "examples": {
                        "example1": "Input: n = 12345\nOutput: 5",
                        "example2": "Input: n = 7\nOutput: 1"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 10^9"
                },
                "hints": {
                        "hint1": "Use a loop to count digits or convert to a string and find its length.",
                        "hint2": "Consider edge cases like single-digit numbers."
                },
                "testCases": {
                        "test1": "Input: 12345 | Output: 5",
                        "test2": "Input: 7 | Output: 1",
                        "test3": "Input: 100000 | Output: 6"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int countDigits(int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def countDigits(self, n: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int countDigits(int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "GCD or HCF",
                "description": "Given two integers a and b, find their Greatest Common Divisor (GCD) or Highest Common Factor (HCF).",
                "topic": "Mathematics",
                "subtopic": "Number Theory",
                "level": "Easy",
                "tags": ["math", "gcd", "euclidean algorithm"],
                "examples": {
                        "example1": "Input: a = 12, b = 18\nOutput: 6",
                        "example2": "Input: a = 17, b = 31\nOutput: 1"
                },
                "constraints": {
                        "constraint1": "1 <= a, b <= 10^9"
                },
                "hints": {
                        "hint1": "Use the Euclidean algorithm to compute GCD.",
                        "hint2": "GCD(a, b) = GCD(b, a % b)."
                },
                "testCases": {
                        "test1": "Input: 12, 18 | Output: 6",
                        "test2": "Input: 17, 31 | Output: 1",
                        "test3": "Input: 100, 200 | Output: 100"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int gcd(int a, int b) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def gcd(self, a: int, b: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int gcd(int a, int b) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Print All Divisors",
                "description": "Given an integer n, print all its divisors in increasing order.",
                "topic": "Mathematics",
                "subtopic": "Number Theory",
                "level": "Easy",
                "tags": ["math", "divisors", "factorization"],
                "examples": {
                        "example1": "Input: n = 12\nOutput: 1, 2, 3, 4, 6, 12",
                        "example2": "Input: n = 7\nOutput: 1, 7"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 10^6"
                },
                "hints": {
                        "hint1": "Iterate from 1 to sqrt(n) and check divisibility.",
                        "hint2": "If i is a divisor, then n/i is also a divisor."
                },
                "testCases": {
                        "test1": "Input: 12 | Output: 1, 2, 3, 4, 6, 12",
                        "test2": "Input: 7 | Output: 1, 7",
                        "test3": "Input: 16 | Output: 1, 2, 4, 8, 16"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void printDivisors(int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def printDivisors(self, n: int):\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    void printDivisors(int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Print Name N Times Using Recursion",
                "description": "Given an integer N, print 'YourName' N times using recursion.",
                "topic": "Recursion",
                "subtopic": "Basic Recursion",
                "level": "Easy",
                "tags": ["recursion", "print"],
                "examples": {
                        "example1": "Input: N = 3\nOutput: 'Alice' 'Alice' 'Alice'",
                        "example2": "Input: N = 2\nOutput: 'Alice' 'Alice'"
                },
                "constraints": {
                        "constraint1": "1 <= N <= 1000"
                },
                "hints": {
                        "hint1": "Use a recursive function to print the name N times."
                },
                "testCases": {
                        "test1": "Input: 3 | Output: 'Alice' 'Alice' 'Alice'",
                        "test2": "Input: 2 | Output: 'Alice' 'Alice'"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void printName(int N) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def printName(self, N: int):\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    void printName(int N) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Print N to 1 Using Recursion",
                "description": "Given an integer N, print numbers from N to 1 using recursion.",
                "topic": "Recursion",
                "subtopic": "Basic Recursion",
                "level": "Easy",
                "tags": ["recursion", "print"],
                "examples": {
                        "example1": "Input: N = 5\nOutput: 5 4 3 2 1",
                        "example2": "Input: N = 3\nOutput: 3 2 1"
                },
                "constraints": {
                        "constraint1": "1 <= N <= 10^4"
                },
                "hints": {
                        "hint1": "Use recursion to decrement N and print each number."
                },
                "testCases": {
                        "test1": "Input: 5 | Output: 5 4 3 2 1",
                        "test2": "Input: 3 | Output: 3 2 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void printNto1(int N) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def printNto1(self, N: int):\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    void printNto1(int N) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Sum of First N Numbers",
                "description": "Given an integer N, find the sum of the first N natural numbers using recursion.",
                "topic": "Recursion",
                "subtopic": "Mathematical Recursion",
                "level": "Easy",
                "tags": ["recursion", "mathematics"],
                "examples": {
                        "example1": "Input: N = 5\nOutput: 15",
                        "example2": "Input: N = 10\nOutput: 55"
                },
                "constraints": {
                        "constraint1": "1 <= N <= 10^4"
                },
                "hints": {
                        "hint1": "Use recursion to add N to the sum of first (N-1) numbers."
                },
                "testCases": {
                        "test1": "Input: 5 | Output: 15",
                        "test2": "Input: 10 | Output: 55"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int sumOfN(int N) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def sumOfN(self, N: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int sumOfN(int N) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Factorial of N Numbers",
                "description": "Given an integer N, find the factorial of N using recursion.",
                "topic": "Recursion",
                "subtopic": "Mathematical Recursion",
                "level": "Easy",
                "tags": ["recursion", "factorial"],
                "examples": {
                        "example1": "Input: N = 5\nOutput: 120",
                        "example2": "Input: N = 3\nOutput: 6"
                },
                "constraints": {
                        "constraint1": "1 <= N <= 12"
                },
                "hints": {
                        "hint1": "Use recursion to multiply N with factorial of (N-1)."
                },
                "testCases": {
                        "test1": "Input: 5 | Output: 120",
                        "test2": "Input: 3 | Output: 6"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int factorial(int N) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def factorial(self, N: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int factorial(int N) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Reverse an Array Using Recursion",
                "description": "Given an array of size N, reverse it using recursion.",
                "topic": "Recursion",
                "subtopic": "Array Manipulation",
                "level": "Easy",
                "tags": ["recursion", "array"],
                "examples": {
                        "example1": "Input: arr = [1, 2, 3, 4, 5]\nOutput: [5, 4, 3, 2, 1]",
                        "example2": "Input: arr = [10, 20, 30]\nOutput: [30, 20, 10]"
                },
                "constraints": {
                        "constraint1": "1 <= N <= 10^4",
                        "constraint2": "-10^6 <= arr[i] <= 10^6"
                },
                "hints": {
                        "hint1": "Use recursion to swap the first and last elements and move inwards."
                },
                "testCases": {
                        "test1": "Input: [1, 2, 3, 4, 5] | Output: [5, 4, 3, 2, 1]",
                        "test2": "Input: [10, 20, 30] | Output: [30, 20, 10]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void reverseArray(int[] arr, int start, int end) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def reverseArray(self, arr: list, start: int, end: int):\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    void reverseArray(vector<int>& arr, int start, int end) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Fibonacci Number",
                "description": "Given an integer N, find the Nth Fibonacci number using recursion.",
                "topic": "Recursion",
                "subtopic": "Mathematical Recursion",
                "level": "Easy",
                "tags": ["recursion", "fibonacci", "mathematics"],
                "examples": {
                        "example1": "Input: N = 5\nOutput: 5",
                        "example2": "Input: N = 10\nOutput: 55"
                },
                "constraints": {
                        "constraint1": "0 <= N <= 30"
                },
                "hints": {
                        "hint1": "Use recursion to compute the sum of the (N-1)th and (N-2)th Fibonacci numbers."
                },
                "testCases": {
                        "test1": "Input: 5 | Output: 5",
                        "test2": "Input: 10 | Output: 55"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int fibonacci(int N) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def fibonacci(self, N: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int fibonacci(int N) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Find the Highest/Lowest Frequency Element",
                "description": "Given an array of integers, find the element with the highest and lowest frequency.",
                "topic": "HashMap",
                "subtopic": "Frequency Count",
                "level": "Medium",
                "tags": ["hashmap", "array", "frequency"],
                "examples": {
                        "example1": "Input: arr = [1, 2, 2, 3, 3, 3, 4]\nOutput: Highest Frequency = 3, Lowest Frequency = 1",
                        "example2": "Input: arr = [5, 5, 5, 2, 2, 3]\nOutput: Highest Frequency = 5, Lowest Frequency = 3"
                },
                "constraints": {
                        "constraint1": "1 <= N <= 10^5",
                        "constraint2": "-10^6 <= arr[i] <= 10^6"
                },
                "hints": {
                        "hint1": "Use a hashmap to count the frequency of each element."
                },
                "testCases": {
                        "test1": "Input: [1, 2, 2, 3, 3, 3, 4] | Output: Highest Frequency = 3, Lowest Frequency = 1",
                        "test2": "Input: [5, 5, 5, 2, 2, 3] | Output: Highest Frequency = 5, Lowest Frequency = 3"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void findFrequencyElements(int[] arr) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findFrequencyElements(self, arr: list):\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    void findFrequencyElements(vector<int>& arr) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Largest Number",
                "description": "Given an array of integers, find the largest number in the array.",
                "topic": "Array",
                "subtopic": "Sorting & Selection",
                "level": "Easy",
                "tags": ["array", "sorting", "selection"],
                "examples": {
                        "example1": "Input: arr = [10, 20, 4, 45, 99]\nOutput: 99",
                        "example2": "Input: arr = [5, 1, 2, 9, 9, 7]\nOutput: 9"
                },
                "constraints": {
                        "constraint1": "1 <= N <= 10^5",
                        "constraint2": "-10^6 <= arr[i] <= 10^6"
                },
                "hints": {
                        "hint1": "Traverse the array and track the maximum number encountered."
                },
                "testCases": {
                        "test1": "Input: [10, 20, 4, 45, 99] | Output: 99",
                        "test2": "Input: [5, 1, 2, 9, 9, 7] | Output: 9"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int findLargest(int[] arr) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findLargest(self, arr: list) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findLargest(vector<int>& arr) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Second Largest Number",
                "description": "Given an array of integers, find the second largest number in the array.",
                "topic": "Array",
                "subtopic": "Sorting & Selection",
                "level": "Easy",
                "tags": ["array", "sorting", "selection"],
                "examples": {
                        "example1": "Input: arr = [10, 20, 4, 45, 99]\nOutput: 45",
                        "example2": "Input: arr = [5, 1, 2, 9, 9, 7]\nOutput: 7"
                },
                "constraints": {
                        "constraint1": "2 <= N <= 10^5",
                        "constraint2": "-10^6 <= arr[i] <= 10^6"
                },
                "hints": {
                        "hint1": "Traverse the array to find the first and second largest elements."
                },
                "testCases": {
                        "test1": "Input: [10, 20, 4, 45, 99] | Output: 45",
                        "test2": "Input: [5, 1, 2, 9, 9, 7] | Output: 7"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int findSecondLargest(int[] arr) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findSecondLargest(self, arr: list) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findSecondLargest(vector<int>& arr) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Decimal to Binary",
                "description": "Given a decimal number, convert it into its binary representation.",
                "topic": "Mathematics",
                "subtopic": "Number System Conversion",
                "level": "Easy",
                "tags": ["math", "binary", "conversion"],
                "examples": {
                        "example1": "Input: num = 10\nOutput: '1010'",
                        "example2": "Input: num = 25\nOutput: '11001'"
                },
                "constraints": {
                        "constraint1": "0 <= num <= 10^6"
                },
                "hints": {
                        "hint1": "Repeatedly divide the number by 2 and store the remainders."
                },
                "testCases": {
                        "test1": "Input: 10 | Output: '1010'",
                        "test2": "Input: 25 | Output: '11001'",
                        "test3": "Input: 0 | Output: '0'"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String decimalToBinary(int num) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def decimalToBinary(self, num: int) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string decimalToBinary(int num) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Binary to Decimal",
                "description": "Given a binary number as a string, convert it into its decimal representation.",
                "topic": "Mathematics",
                "subtopic": "Number System Conversion",
                "level": "Easy",
                "tags": ["math", "binary", "conversion"],
                "examples": {
                        "example1": "Input: binary = '1010'\nOutput: 10",
                        "example2": "Input: binary = '11001'\nOutput: 25"
                },
                "constraints": {
                        "constraint1": "1 <= binary.length <= 20",
                        "constraint2": "binary[i] is '0' or '1'"
                },
                "hints": {
                        "hint1": "Each digit represents a power of 2 based on its position."
                },
                "testCases": {
                        "test1": "Input: '1010' | Output: 10",
                        "test2": "Input: '11001' | Output: 25",
                        "test3": "Input: '0' | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int binaryToDecimal(String binary) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def binaryToDecimal(self, binary: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int binaryToDecimal(string binary) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Armstrong Number",
                "description": "A number is called an Armstrong number if the sum of its digits each raised to the power of the number of digits equals the number itself. Given an integer, determine if it is an Armstrong number.",
                "topic": "Mathematics",
                "subtopic": "Number Theory",
                "level": "Easy",
                "tags": ["math", "number theory", "digits"],
                "examples": {
                        "example1": "Input: num = 153\nOutput: true",
                        "example2": "Input: num = 9474\nOutput: true",
                        "example3": "Input: num = 123\nOutput: false"
                },
                "constraints": {
                        "constraint1": "0 <= num <= 10^9"
                },
                "hints": {
                        "hint1": "Find the number of digits in the given number.",
                        "hint2": "Compute the sum of each digit raised to the power of the total number of digits."
                },
                "testCases": {
                        "test1": "Input: 153 | Output: true",
                        "test2": "Input: 9474 | Output: true",
                        "test3": "Input: 123 | Output: false",
                        "test4": "Input: 9475 | Output: false"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isArmstrong(int num) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isArmstrong(self, num: int) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isArmstrong(int num) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Contains Duplicate",
                "description": "Given an integer array nums, return true if any value appears at least twice in the array, and false if every element is distinct.",
                "topic": "Array",
                "subtopic": "Hashing",
                "level": "Easy",
                "tags": ["array", "hashing", "duplicates"],
                "examples": {
                        "example1": "Input: nums = [1,2,3,1]\nOutput: true",
                        "example2": "Input: nums = [1,2,3,4]\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^5",
                        "constraint2": "-10^9 <= nums[i] <= 10^9"
                },
                "hints": {
                        "hint1": "Use a set to track seen numbers.",
                        "hint2": "Sort the array and check adjacent elements."
                },
                "testCases": {
                        "test1": "Input: [1,2,3,1] | Output: true",
                        "test2": "Input: [1,2,3,4] | Output: false",
                        "test3": "Input: [7,8,9,7,10] | Output: true",
                        "test4": "Input: [10,20,30,40,50] | Output: false",
                        "test5": "Input: [5,5,5,5] | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Valid Anagram",
                "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
                "topic": "Strings",
                "subtopic": "Hashing",
                "level": "Easy",
                "tags": ["string", "hashing", "anagram"],
                "examples": {
                        "example1": "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true",
                        "example2": "Input: s = \"rat\", t = \"car\"\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= s.length, t.length <= 5 * 10^4",
                        "constraint2": "s and t consist of lowercase English letters."
                },
                "hints": {
                        "hint1": "Use a hash map to count character frequencies.",
                        "hint2": "Sort both strings and compare them."
                },
                "testCases": {
                        "test1": "Input: s = \"listen\", t = \"silent\" | Output: true",
                        "test2": "Input: s = \"hello\", t = \"world\" | Output: false",
                        "test3": "Input: s = \"aacc\", t = \"ccac\" | Output: false",
                        "test4": "Input: s = \"cinema\", t = \"iceman\" | Output: true",
                        "test5": "Input: s = \"a\", t = \"a\" | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Two Sum",
                "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
                "topic": "Array",
                "subtopic": "Hashing",
                "level": "Easy",
                "tags": ["array", "hashing", "two-pointer"],
                "examples": {
                        "example1": "Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]",
                        "example2": "Input: nums = [3,2,4], target = 6\nOutput: [1,2]"
                },
                "constraints": {
                        "constraint1": "2 <= nums.length <= 10^4",
                        "constraint2": "-10^9 <= nums[i] <= 10^9",
                        "constraint3": "-10^9 <= target <= 10^9",
                        "constraint4": "Exactly one valid answer exists."
                },
                "hints": {
                        "hint1": "Use a hash map to store indices of visited numbers.",
                        "hint2": "Iterate through the array and check if the complement exists in the hash map."
                },
                "testCases": {
                        "test1": "Input: nums = [2,7,11,15], target = 9 | Output: [0,1]",
                        "test2": "Input: nums = [3,2,4], target = 6 | Output: [1,2]",
                        "test3": "Input: nums = [1,5,3], target = 8 | Output: [1,2]",
                        "test4": "Input: nums = [-3,4,3,90], target = 0 | Output: [0,2]",
                        "test5": "Input: nums = [1,2,3,4,5], target = 9 | Output: [3,4]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Group Anagrams",
                "description": "Given an array of strings strs, group the anagrams together.",
                "topic": "Strings",
                "subtopic": "Hashing",
                "level": "Medium",
                "tags": ["strings", "hashing", "sorting"],
                "examples": {
                        "example1": "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
                        "example2": "Input: strs = [\"\"]\nOutput: [[\"\"]]",
                        "example3": "Input: strs = [\"a\"]\nOutput: [[\"a\"]]"
                },
                "constraints": {
                        "constraint1": "1 <= strs.length <= 10^4",
                        "constraint2": "0 <= strs[i].length <= 100",
                        "constraint3": "strs[i] consists of lowercase English letters."
                },
                "hints": {
                        "hint1": "Sort each word and use it as a key in a hash map.",
                        "hint2": "Use a hash map to store words that share the same sorted key."
                },
                "testCases": {
                        "test1": "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] | Output: [[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
                        "test2": "Input: strs = [\"\"] | Output: [[\"\"]]",
                        "test3": "Input: strs = [\"a\"] | Output: [[\"a\"]]",
                        "test4": "Input: strs = [\"abc\",\"cba\",\"bca\",\"xyz\",\"yxz\",\"zxy\"] | Output: [[\"abc\",\"cba\",\"bca\"],[\"xyz\",\"yxz\",\"zxy\"]]",
                        "test5": "Input: strs = [\"hello\",\"olleh\",\"world\",\"dlrow\"] | Output: [[\"hello\",\"olleh\"],[\"world\",\"dlrow\"]]"
                },
                "codeSnippets": {
                        "java": "import java.util.*;\n\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        // Write your code here\n    }\n}",
                        "python": "from typing import List\n\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Top K Frequent Elements",
                "description": "Given an integer array nums and an integer k, return the k most frequent elements.",
                "topic": "Hashing",
                "subtopic": "Heap/Priority Queue",
                "level": "Medium",
                "tags": ["hashing", "heap", "sorting"],
                "examples": {
                        "example1": "Input: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]",
                        "example2": "Input: nums = [1], k = 1\nOutput: [1]"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^5",
                        "constraint2": "-10^4 <= nums[i] <= 10^4",
                        "constraint3": "1 <= k <= number of unique elements in nums",
                        "constraint4": "The answer is unique."
                },
                "hints": {
                        "hint1": "Use a hash map to count element frequencies.",
                        "hint2": "Use a heap or sorting to find the top k frequent elements efficiently."
                },
                "testCases": {
                        "test1": "Input: nums = [1,1,1,2,2,3], k = 2 | Output: [1,2]",
                        "test2": "Input: nums = [1], k = 1 | Output: [1]",
                        "test3": "Input: nums = [4,4,4,6,6,7,7,7,8,8,8,8], k = 3 | Output: [8,7,4]",
                        "test4": "Input: nums = [10,10,20,20,20,30,30,30,30], k = 2 | Output: [30,20]",
                        "test5": "Input: nums = [5,5,5,6,6,6,7,7], k = 2 | Output: [5,6]"
                },
                "codeSnippets": {
                        "java": "import java.util.*;\n\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        // Write your code here\n    }\n}",
                        "python": "from typing import List\n\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <unordered_map>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Concatenation of Array",
                "description": "Given an integer array nums of length n, return an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n.",
                "topic": "Array",
                "subtopic": "Basic Operations",
                "level": "Easy",
                "tags": ["array", "concatenation"],
                "examples": {
                        "example1": "Input: nums = [1,2,1]\nOutput: [1,2,1,1,2,1]",
                        "example2": "Input: nums = [1,3,2,1]\nOutput: [1,3,2,1,1,3,2,1]"
                },
                "constraints": {
                        "constraint1": "n == nums.length",
                        "constraint2": "1 <= n <= 1000",
                        "constraint3": "-10^6 <= nums[i] <= 10^6"
                },
                "hints": {
                        "hint1": "Create a new array of size 2n and copy nums twice.",
                        "hint2": "Use list or array concatenation in your programming language."
                },
                "testCases": {
                        "test1": "Input: nums = [1,2,1] | Output: [1,2,1,1,2,1]",
                        "test2": "Input: nums = [1,3,2,1] | Output: [1,3,2,1,1,3,2,1]",
                        "test3": "Input: nums = [5,6] | Output: [5,6,5,6]",
                        "test4": "Input: nums = [10] | Output: [10,10]",
                        "test5": "Input: nums = [7,8,9] | Output: [7,8,9,7,8,9]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] getConcatenation(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "from typing import List\n\nclass Solution:\n    def getConcatenation(self, nums: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> getConcatenation(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Replace Elements With Greatest Element On Right Side",
                "description": "Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1. Return the modified array.",
                "topic": "Array",
                "subtopic": "Element Replacement",
                "level": "Easy",
                "tags": ["array", "modification", "greedy"],
                "examples": {
                        "example1": "Input: arr = [17,18,5,4,6,1]\nOutput: [18,6,6,6,1,-1]",
                        "example2": "Input: arr = [400]\nOutput: [-1]"
                },
                "constraints": {
                        "constraint1": "1 <= arr.length <= 10^4",
                        "constraint2": "1 <= arr[i] <= 10^5"
                },
                "hints": {
                        "hint1": "Iterate the array from right to left.",
                        "hint2": "Keep track of the maximum seen so far and update elements accordingly."
                },
                "testCases": {
                        "test1": "Input: arr = [17,18,5,4,6,1] | Output: [18,6,6,6,1,-1]",
                        "test2": "Input: arr = [400] | Output: [-1]",
                        "test3": "Input: arr = [10,9,8,7,6,5] | Output: [9,8,7,6,5,-1]",
                        "test4": "Input: arr = [1,2,3,4,5] | Output: [5,5,5,5,-1]",
                        "test5": "Input: arr = [100,90,80,70] | Output: [90,80,70,-1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] replaceElements(int[] arr) {\n        // Write your code here\n    }\n}",
                        "python": "from typing import List\n\nclass Solution:\n    def replaceElements(self, arr: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> replaceElements(vector<int>& arr) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Is Subsequence",
                "description": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.",
                "topic": "String",
                "subtopic": "Subsequence Check",
                "level": "Easy",
                "tags": ["string", "subsequence", "two pointers"],
                "examples": {
                        "example1": "Input: s = \"abc\", t = \"ahbgdc\"\nOutput: true",
                        "example2": "Input: s = \"axc\", t = \"ahbgdc\"\nOutput: false"
                },
                "constraints": {
                        "constraint1": "0 <= s.length <= 100",
                        "constraint2": "0 <= t.length <= 10^4",
                        "constraint3": "s and t consist only of lowercase English letters."
                },
                "hints": {
                        "hint1": "Use two pointers to iterate through both strings.",
                        "hint2": "If all characters of s appear in t in order, return true."
                },
                "testCases": {
                        "test1": "Input: s = \"abc\", t = \"ahbgdc\" | Output: true",
                        "test2": "Input: s = \"axc\", t = \"ahbgdc\" | Output: false",
                        "test3": "Input: s = \"\", t = \"ahbgdc\" | Output: true",
                        "test4": "Input: s = \"b\", t = \"abc\" | Output: true",
                        "test5": "Input: s = \"abc\", t = \"acb\" | Output: false"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Length of Last Word",
                "description": "Given a string s consisting of words and spaces, return the length of the last word in the string. A word is defined as a maximal substring consisting of non-space characters only.",
                "topic": "String",
                "subtopic": "Basic String Manipulation",
                "level": "Easy",
                "tags": ["string", "words", "trimming"],
                "examples": {
                        "example1": "Input: s = \"Hello World\"\nOutput: 5",
                        "example2": "Input: s = \"   fly me   to   the moon  \"\nOutput: 4"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 10^4",
                        "constraint2": "s consists of only English letters and spaces.",
                        "constraint3": "There will be at least one word in s."
                },
                "hints": {
                        "hint1": "Trim trailing spaces before processing.",
                        "hint2": "Find the last word by iterating from the end."
                },
                "testCases": {
                        "test1": "Input: \"Hello World\" | Output: 5",
                        "test2": "Input: \"   fly me   to   the moon  \" | Output: 4",
                        "test3": "Input: \"luffy is still joyboy\" | Output: 6",
                        "test4": "Input: \"a \" | Output: 1",
                        "test5": "Input: \"Today is a beautiful day\" | Output: 3"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int lengthOfLastWord(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Longest Common Prefix",
                "description": "Given an array of strings strs, return the longest common prefix among them. If there is no common prefix, return an empty string \"\".",
                "topic": "String",
                "subtopic": "Prefix Matching",
                "level": "Easy",
                "tags": ["string", "prefix", "array"],
                "examples": {
                        "example1": "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
                        "example2": "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\""
                },
                "constraints": {
                        "constraint1": "1 <= strs.length <= 200",
                        "constraint2": "0 <= strs[i].length <= 200",
                        "constraint3": "strs[i] consists of only lowercase English letters."
                },
                "hints": {
                        "hint1": "Compare character by character in each string.",
                        "hint2": "Use sorting to simplify prefix comparison."
                },
                "testCases": {
                        "test1": "Input: [\"flower\",\"flow\",\"flight\"] | Output: \"fl\"",
                        "test2": "Input: [\"dog\",\"racecar\",\"car\"] | Output: \"\"",
                        "test3": "Input: [\"interspecies\",\"interstellar\",\"interstate\"] | Output: \"inters\"",
                        "test4": "Input: [\"a\"] | Output: \"a\"",
                        "test5": "Input: [\"ab\",\"a\"] | Output: \"a\""
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Pascal's Triangle",
                "description": "Given an integer numRows, return the first numRows of Pascal's triangle. Each row is the sum of the two directly above it.",
                "topic": "Mathematics",
                "subtopic": "Combinatorics",
                "level": "Easy",
                "tags": ["math", "combinatorics", "triangle"],
                "examples": {
                        "example1": "Input: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
                        "example2": "Input: numRows = 1\nOutput: [[1]]"
                },
                "constraints": {
                        "constraint1": "1 <= numRows <= 30"
                },
                "hints": {
                        "hint1": "Each row starts and ends with 1.",
                        "hint2": "Each middle element is the sum of the two elements above it."
                },
                "testCases": {
                        "test1": "Input: 5 | Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
                        "test2": "Input: 1 | Output: [[1]]",
                        "test3": "Input: 3 | Output: [[1],[1,1],[1,2,1]]",
                        "test4": "Input: 6 | Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1]]",
                        "test5": "Input: 2 | Output: [[1],[1,1]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> generate(int numRows) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Remove Element",
                "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed. Return the new length of the array.",
                "topic": "Array",
                "subtopic": "In-place Modification",
                "level": "Easy",
                "tags": ["array", "two-pointer", "in-place"],
                "examples": {
                        "example1": "Input: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_ , _]",
                        "example2": "Input: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,3,0,4,_,_,_]"
                },
                "constraints": {
                        "constraint1": "0 <= nums.length <= 100",
                        "constraint2": "0 <= nums[i] <= 50",
                        "constraint3": "0 <= val <= 50"
                },
                "hints": {
                        "hint1": "Use two pointers to track the position where elements should be placed.",
                        "hint2": "You don’t need to remove elements physically, just overwrite them."
                },
                "testCases": {
                        "test1": "Input: nums = [3,2,2,3], val = 3 | Output: 2",
                        "test2": "Input: nums = [0,1,2,2,3,0,4,2], val = 2 | Output: 5",
                        "test3": "Input: nums = [1,1,1,1], val = 1 | Output: 0",
                        "test4": "Input: nums = [2,2,3,4,5], val = 6 | Output: 5",
                        "test5": "Input: nums = [], val = 0 | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Unique Email Addresses",
                "description": "Given an array of strings emails, we need to send an email to each unique address. Return the number of unique email addresses.",
                "topic": "String",
                "subtopic": "String Manipulation",
                "level": "Easy",
                "tags": ["string", "email", "hashset"],
                "examples": {
                        "example1": "Input: emails = [\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"]\nOutput: 2",
                        "example2": "Input: emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "1 <= emails.length <= 100",
                        "constraint2": "1 <= emails[i].length <= 100",
                        "constraint3": "emails[i] consist of lowercase English letters, '.', '+', and '@'.",
                        "constraint4": "Each emails[i] contains exactly one '@' character."
                },
                "hints": {
                        "hint1": "Ignore everything after a '+' sign before '@'.",
                        "hint2": "Remove '.' before '@' but keep the domain part intact."
                },
                "testCases": {
                        "test1": "Input: [\"test.email+alex@leetcode.com\", \"test.email.leet+alex@code.com\"] | Output: 2",
                        "test2": "Input: [\"a@leetcode.com\", \"b@leetcode.com\", \"c@leetcode.com\"] | Output: 3",
                        "test3": "Input: [\"test.email+alex@leetcode.com\", \"test.email@leetcode.com\"] | Output: 1",
                        "test4": "Input: [\"x.y+z@leetcode.com\", \"xy@leetcode.com\"] | Output: 1",
                        "test5": "Input: [\"abc@abc.com\"] | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int numUniqueEmails(String[] emails) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def numUniqueEmails(self, emails: List[str]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numUniqueEmails(vector<string>& emails) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Isomorphic Strings",
                "description": "Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t.",
                "topic": "String",
                "subtopic": "Character Mapping",
                "level": "Easy",
                "tags": ["string", "hashmap", "mapping"],
                "examples": {
                        "example1": "Input: s = \"egg\", t = \"add\"\nOutput: true",
                        "example2": "Input: s = \"foo\", t = \"bar\"\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= s.length, t.length <= 5 * 10^4",
                        "constraint2": "s and t consist of any printable ASCII characters."
                },
                "hints": {
                        "hint1": "Use a hash map to track character mappings.",
                        "hint2": "Ensure that the mapping is one-to-one."
                },
                "testCases": {
                        "test1": "Input: s = \"egg\", t = \"add\" | Output: true",
                        "test2": "Input: s = \"foo\", t = \"bar\" | Output: false",
                        "test3": "Input: s = \"paper\", t = \"title\" | Output: true",
                        "test4": "Input: s = \"ab\", t = \"aa\" | Output: false",
                        "test5": "Input: s = \"abc\", t = \"bca\" | Output: false"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Can Place Flowers",
                "description": "Given a flowerbed represented as an array of 0s and 1s, check if n new flowers can be planted without violating the no-adjacent-flowers rule.",
                "topic": "Array",
                "subtopic": "Greedy",
                "level": "Easy",
                "tags": ["array", "greedy"],
                "examples": {
                        "example1": "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
                        "example2": "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= flowerbed.length <= 2 * 10^4",
                        "constraint2": "flowerbed[i] is either 0 or 1.",
                        "constraint3": "There are no two adjacent 1s in the flowerbed initially.",
                        "constraint4": "0 <= n <= flowerbed.length"
                },
                "hints": {
                        "hint1": "Use a greedy approach to check if a flower can be planted.",
                        "hint2": "Modify the array in place to track available spots."
                },
                "testCases": {
                        "test1": "Input: flowerbed = [1,0,0,0,1], n = 1 | Output: true",
                        "test2": "Input: flowerbed = [1,0,0,0,1], n = 2 | Output: false",
                        "test3": "Input: flowerbed = [0,0,1,0,1], n = 1 | Output: true",
                        "test4": "Input: flowerbed = [0,0,0,0,0], n = 3 | Output: true",
                        "test5": "Input: flowerbed = [1,0,1,0,1], n = 0 | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Majority Element",
                "description": "Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊n/2⌋ times.",
                "topic": "Array",
                "subtopic": "Boyer-Moore Voting Algorithm",
                "level": "Easy",
                "tags": ["array", "hashmap", "Boyer-Moore"],
                "examples": {
                        "example1": "Input: nums = [3,2,3]\nOutput: 3",
                        "example2": "Input: nums = [2,2,1,1,1,2,2]\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 5 * 10^4",
                        "constraint2": "-10^9 <= nums[i] <= 10^9"
                },
                "hints": {
                        "hint1": "Use a hashmap to count occurrences of elements.",
                        "hint2": "Use Boyer-Moore Voting Algorithm for an optimal solution."
                },
                "testCases": {
                        "test1": "Input: nums = [3,2,3] | Output: 3",
                        "test2": "Input: nums = [2,2,1,1,1,2,2] | Output: 2",
                        "test3": "Input: nums = [1,1,1,2,2] | Output: 1",
                        "test4": "Input: nums = [1,2,3,4,4,4,4] | Output: 4",
                        "test5": "Input: nums = [5,5,5,5,5,5,6] | Output: 5"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int majorityElement(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Next Greater Element I",
                "description": "You are given two integer arrays nums1 and nums2, where nums1 is a subset of nums2. Find the next greater element for each element in nums1 within nums2.",
                "topic": "Stack",
                "subtopic": "Monotonic Stack",
                "level": "Easy",
                "tags": ["stack", "monotonic stack", "array"],
                "examples": {
                        "example1": "Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]",
                        "example2": "Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]"
                },
                "constraints": {
                        "constraint1": "1 <= nums1.length <= nums2.length <= 1000",
                        "constraint2": "0 <= nums1[i], nums2[i] <= 10^4",
                        "constraint3": "All integers in nums1 and nums2 are unique."
                },
                "hints": {
                        "hint1": "Use a stack to keep track of elements for which the next greater element hasn't been found yet.",
                        "hint2": "Use a hashmap to store the next greater element for each number in nums2."
                },
                "testCases": {
                        "test1": "Input: nums1 = [4,1,2], nums2 = [1,3,4,2] | Output: [-1,3,-1]",
                        "test2": "Input: nums1 = [2,4], nums2 = [1,2,3,4] | Output: [3,-1]",
                        "test3": "Input: nums1 = [1,3,5], nums2 = [1,2,3,4,5] | Output: [2,4,-1]",
                        "test4": "Input: nums1 = [5,6], nums2 = [1,3,5,7,6,4] | Output: [7,-1]",
                        "test5": "Input: nums1 = [2,3], nums2 = [2,3,1] | Output: [-1,-1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Find Pivot Index",
                "description": "Given an array of integers nums, return the pivot index where the sum of the left side is equal to the sum of the right side. If no pivot index exists, return -1.",
                "topic": "Array",
                "subtopic": "Prefix Sum",
                "level": "Easy",
                "tags": ["array", "prefix sum"],
                "examples": {
                        "example1": "Input: nums = [1,7,3,6,5,6]\nOutput: 3",
                        "example2": "Input: nums = [1,2,3]\nOutput: -1"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^4",
                        "constraint2": "-1000 <= nums[i] <= 1000"
                },
                "hints": {
                        "hint1": "Use prefix sum to track left and right sums efficiently.",
                        "hint2": "Update left sum dynamically as you iterate through the array."
                },
                "testCases": {
                        "test1": "Input: nums = [1,7,3,6,5,6] | Output: 3",
                        "test2": "Input: nums = [1,2,3] | Output: -1",
                        "test3": "Input: nums = [2,1,-1] | Output: 0",
                        "test4": "Input: nums = [0,0,0,0,1] | Output: 4",
                        "test5": "Input: nums = [-1,-1,-1,-1,-1,0] | Output: 2"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int pivotIndex(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def pivotIndex(self, nums: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int pivotIndex(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Range Sum Query - Immutable",
                "description": "Given an integer array nums, implement a NumArray class with a sumRange method that calculates the sum of elements in a given range.",
                "topic": "Array",
                "subtopic": "Prefix Sum",
                "level": "Easy",
                "tags": ["array", "prefix sum"],
                "examples": {
                        "example1": "Input: nums = [-2, 0, 3, -5, 2, -1]\nQuery: sumRange(0,2)\nOutput: 1",
                        "example2": "Input: nums = [-2, 0, 3, -5, 2, -1]\nQuery: sumRange(2,5)\nOutput: -1"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^4",
                        "constraint2": "-10^5 <= nums[i] <= 10^5",
                        "constraint3": "0 <= left <= right < nums.length"
                },
                "hints": {
                        "hint1": "Use a prefix sum array to preprocess sums efficiently.",
                        "hint2": "Precompute cumulative sums so that range queries take O(1) time."
                },
                "testCases": {
                        "test1": "Input: nums = [-2, 0, 3, -5, 2, -1] | Query: sumRange(0,2) | Output: 1",
                        "test2": "Input: nums = [-2, 0, 3, -5, 2, -1] | Query: sumRange(2,5) | Output: -1",
                        "test3": "Input: nums = [1,2,3,4,5] | Query: sumRange(1,3) | Output: 9",
                        "test4": "Input: nums = [5,5,5,5] | Query: sumRange(0,3) | Output: 20",
                        "test5": "Input: nums = [0,0,0,0,0] | Query: sumRange(2,4) | Output: 0"
                },
                "codeSnippets": {
                        "java": "class NumArray {\n    public NumArray(int[] nums) {\n        // Write your code here\n    }\n    \n    public int sumRange(int left, int right) {\n        // Write your code here\n    }\n}",
                        "python": "class NumArray:\n    def __init__(self, nums: List[int]):\n        # Write your code here\n        pass\n    \n    def sumRange(self, left: int, right: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass NumArray {\npublic:\n    NumArray(vector<int>& nums) {\n        // Write your code here\n    }\n    \n    int sumRange(int left, int right) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Find All Numbers Disappeared in an Array",
                "description": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.",
                "topic": "Array",
                "subtopic": "Hashing",
                "level": "Easy",
                "tags": ["array", "hashing"],
                "examples": {
                        "example1": "Input: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]",
                        "example2": "Input: nums = [1,1]\nOutput: [2]"
                },
                "constraints": {
                        "constraint1": "n == nums.length",
                        "constraint2": "1 <= n <= 10^5",
                        "constraint3": "1 <= nums[i] <= n"
                },
                "hints": {
                        "hint1": "Mark the presence of numbers by modifying the array.",
                        "hint2": "Iterate through the array to identify missing numbers."
                },
                "testCases": {
                        "test1": "Input: [4,3,2,7,8,2,3,1] | Output: [5,6]",
                        "test2": "Input: [1,1] | Output: [2]",
                        "test3": "Input: [2,2] | Output: [1]",
                        "test4": "Input: [1,2,3,4,5] | Output: []",
                        "test5": "Input: [10,9,8,7,6,5,4,3,2,1] | Output: []"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Maximum Number of Balloons",
                "description": "Given a string text, return the maximum number of times the word 'balloon' can be formed using the letters from text.",
                "topic": "String",
                "subtopic": "Frequency Counting",
                "level": "Easy",
                "tags": ["string", "hashmap"],
                "examples": {
                        "example1": "Input: text = 'nlaebolko'\nOutput: 1",
                        "example2": "Input: text = 'loonbalxballpoon'\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "1 <= text.length <= 10^4",
                        "constraint2": "text consists of lowercase English letters."
                },
                "hints": {
                        "hint1": "Count the frequency of each letter in 'balloon'.",
                        "hint2": "Find the limiting letter that determines the max count."
                },
                "testCases": {
                        "test1": "Input: 'nlaebolko' | Output: 1",
                        "test2": "Input: 'loonbalxballpoon' | Output: 2",
                        "test3": "Input: 'leetcode' | Output: 0",
                        "test4": "Input: 'ballonballoon' | Output: 1",
                        "test5": "Input: 'bbaaoollonn' | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int maxNumberOfBalloons(String text) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def maxNumberOfBalloons(self, text: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxNumberOfBalloons(string text) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Word Pattern",
                "description": "Given a pattern and a string s, find if s follows the same pattern.",
                "topic": "String",
                "subtopic": "Hash Map",
                "level": "Easy",
                "tags": ["string", "hashmap"],
                "examples": {
                        "example1": "Input: pattern = 'abba', s = 'dog cat cat dog'\nOutput: true",
                        "example2": "Input: pattern = 'abba', s = 'dog cat cat fish'\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= pattern.length <= 300",
                        "constraint2": "pattern contains only lowercase English letters.",
                        "constraint3": "1 <= s.length <= 3000",
                        "constraint4": "s contains only lowercase English letters and spaces."
                },
                "hints": {
                        "hint1": "Use a map to store mappings between pattern and words.",
                        "hint2": "Check if the mappings are one-to-one."
                },
                "testCases": {
                        "test1": "Input: 'abba', 'dog cat cat dog' | Output: true",
                        "test2": "Input: 'abba', 'dog cat cat fish' | Output: false",
                        "test3": "Input: 'aaaa', 'dog cat cat dog' | Output: false",
                        "test4": "Input: 'abba', 'dog dog dog dog' | Output: false",
                        "test5": "Input: 'abc', 'dog cat mouse' | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean wordPattern(String pattern, String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Design HashSet",
                "description": "Design a HashSet without using any built-in hash table libraries.",
                "topic": "Data Structures",
                "subtopic": "Hashing",
                "level": "Easy",
                "tags": ["hashset", "data structure", "design"],
                "examples": {
                        "example1": "Input: ['MyHashSet', 'add', 'remove', 'contains']\n       [[], [1], [2], [1]]\nOutput: [null, null, null, true]",
                        "example2": "Input: ['MyHashSet', 'add', 'add', 'contains', 'remove', 'contains']\n       [[], [1], [2], [2], [2], [2]]\nOutput: [null, null, null, true, null, false]"
                },
                "constraints": {
                        "constraint1": "0 <= key <= 10^6",
                        "constraint2": "At most 10^4 calls will be made to add, remove, and contains."
                },
                "hints": {
                        "hint1": "Use an array or linked list to store values.",
                        "hint2": "Optimize lookups for better efficiency."
                },
                "testCases": {
                        "test1": "Input: ['MyHashSet', 'add', 'contains', 'remove', 'contains'] | [[], [1], [1], [1], [1]] | Output: [null, null, true, null, false]",
                        "test2": "Input: ['MyHashSet', 'add', 'add', 'contains'] | [[], [100], [200], [100]] | Output: [null, null, null, true]"
                },
                "codeSnippets": {
                        "java": "class MyHashSet {\n    public MyHashSet() {\n        // Initialize data structure\n    }\n    public void add(int key) {\n        // Write your code here\n    }\n    public void remove(int key) {\n        // Write your code here\n    }\n    public boolean contains(int key) {\n        // Write your code here\n        return false;\n    }\n}",
                        "python": "class MyHashSet:\n    def __init__(self):\n        # Initialize data structure\n        pass\n    def add(self, key: int) -> None:\n        # Write your code here\n        pass\n    def remove(self, key: int) -> None:\n        # Write your code here\n        pass\n    def contains(self, key: int) -> bool:\n        # Write your code here\n        return False",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass MyHashSet {\npublic:\n    MyHashSet() {\n        // Initialize data structure\n    }\n    void add(int key) {\n        // Write your code here\n    }\n    void remove(int key) {\n        // Write your code here\n    }\n    bool contains(int key) {\n        // Write your code here\n        return false;\n    }\n};"
                }
        },
        {
                "title": "Design HashMap",
                "description": "Design a HashMap without using any built-in hash table libraries.",
                "topic": "Data Structures",
                "subtopic": "Hashing",
                "level": "Easy",
                "tags": ["hashmap", "data structure", "design"],
                "examples": {
                        "example1": "Input: ['MyHashMap', 'put', 'get', 'remove', 'get']\n       [[], [1,2], [1], [1], [1]]\nOutput: [null, null, 2, null, -1]",
                        "example2": "Input: ['MyHashMap', 'put', 'put', 'get', 'remove', 'get']\n       [[], [1,2], [2,3], [1], [2], [2]]\nOutput: [null, null, null, 2, null, -1]"
                },
                "constraints": {
                        "constraint1": "0 <= key, value <= 10^6",
                        "constraint2": "At most 10^4 calls will be made to put, get, and remove."
                },
                "hints": {
                        "hint1": "Use an array or linked list to store key-value pairs.",
                        "hint2": "Optimize lookups for better efficiency."
                },
                "testCases": {
                        "test1": "Input: ['MyHashMap', 'put', 'get', 'remove', 'get'] | [[], [1, 10], [1], [1], [1]] | Output: [null, null, 10, null, -1]",
                        "test2": "Input: ['MyHashMap', 'put', 'put', 'get', 'remove', 'get'] | [[], [2, 20], [3, 30], [2], [3], [3]] | Output: [null, null, null, 20, null, -1]"
                },
                "codeSnippets": {
                        "java": "class MyHashMap {\n    public MyHashMap() {\n        // Initialize data structure\n    }\n    public void put(int key, int value) {\n        // Write your code here\n    }\n    public int get(int key) {\n        // Write your code here\n        return -1;\n    }\n    public void remove(int key) {\n        // Write your code here\n    }\n}",
                        "python": "class MyHashMap:\n    def __init__(self):\n        # Initialize data structure\n        pass\n    def put(self, key: int, value: int) -> None:\n        # Write your code here\n        pass\n    def get(self, key: int) -> int:\n        # Write your code here\n        return -1\n    def remove(self, key: int) -> None:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass MyHashMap {\npublic:\n    MyHashMap() {\n        // Initialize data structure\n    }\n    void put(int key, int value) {\n        // Write your code here\n    }\n    int get(int key) {\n        // Write your code here\n        return -1;\n    }\n    void remove(int key) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Monotonic Array",
                "description": "An array is monotonic if it is either monotone increasing or decreasing. Given an array nums, return true if the array is monotonic, otherwise return false.",
                "topic": "Array",
                "subtopic": "Sorting",
                "level": "Easy",
                "tags": ["array", "monotonic"],
                "examples": {
                        "example1": "Input: nums = [1,2,2,3]\nOutput: true",
                        "example2": "Input: nums = [6,5,4,4]\nOutput: true",
                        "example3": "Input: nums = [1,3,2]\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^5",
                        "constraint2": "-10^5 <= nums[i] <= 10^5"
                },
                "hints": {
                        "hint1": "Check if the array is entirely non-increasing or non-decreasing.",
                        "hint2": "Use two flags to track increasing and decreasing trends."
                },
                "testCases": {
                        "test1": "Input: [1,2,2,3] | Output: true",
                        "test2": "Input: [6,5,4,4] | Output: true",
                        "test3": "Input: [1,3,2] | Output: false",
                        "test4": "Input: [1,1,1,1] | Output: true",
                        "test5": "Input: [10,9,8,7,6,5,4,3,2,1] | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isMonotonic(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isMonotonic(self, nums: List[int]) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isMonotonic(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Number of Good Pairs",
                "description": "Given an array of integers nums, return the number of good pairs. A pair (i, j) is called good if nums[i] == nums[j] and i < j.",
                "topic": "Array",
                "subtopic": "Counting",
                "level": "Easy",
                "tags": ["array", "hashmap", "counting"],
                "examples": {
                        "example1": "Input: nums = [1,2,3,1,1,3]\nOutput: 4",
                        "example2": "Input: nums = [1,1,1,1]\nOutput: 6"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 100",
                        "constraint2": "1 <= nums[i] <= 100"
                },
                "hints": {
                        "hint1": "Use a hashmap to count occurrences of each number.",
                        "hint2": "Use the formula nC2 = (n * (n-1)) / 2 for each count."
                },
                "testCases": {
                        "test1": "Input: [1,2,3,1,1,3] | Output: 4",
                        "test2": "Input: [1,1,1,1] | Output: 6",
                        "test3": "Input: [1,2,3] | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int numIdenticalPairs(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def numIdenticalPairs(self, nums: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n\nclass Solution {\npublic:\n    int numIdenticalPairs(std::vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Pascal's Triangle II",
                "description": "Given an integer rowIndex, return the rowIndex-th (0-indexed) row of Pascal's Triangle.",
                "topic": "Mathematics",
                "subtopic": "Combinatorics",
                "level": "Easy",
                "tags": ["math", "pascal's triangle", "array"],
                "examples": {
                        "example1": "Input: rowIndex = 3\nOutput: [1,3,3,1]",
                        "example2": "Input: rowIndex = 0\nOutput: [1]"
                },
                "constraints": {
                        "constraint1": "0 <= rowIndex <= 33"
                },
                "hints": {
                        "hint1": "Use a single list to compute the row in-place.",
                        "hint2": "Use the formula C(n, k) = C(n, k-1) * (n-k+1) / k."
                },
                "testCases": {
                        "test1": "Input: 3 | Output: [1,3,3,1]",
                        "test2": "Input: 0 | Output: [1]",
                        "test3": "Input: 1 | Output: [1,1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<Integer> getRow(int rowIndex) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> getRow(int rowIndex) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Find Words That Can Be Formed by Characters",
                "description": "You are given an array of words and a string chars. Return the sum of lengths of all words that can be formed using the given characters exactly as many times as they appear.",
                "topic": "Strings",
                "subtopic": "Hashing",
                "level": "Easy",
                "tags": ["string", "hashmap", "counting"],
                "examples": {
                        "example1": "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6",
                        "example2": "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10"
                },
                "constraints": {
                        "constraint1": "1 <= words.length <= 1000",
                        "constraint2": "1 <= words[i].length, chars.length <= 100",
                        "constraint3": "words[i] and chars contain only lowercase English letters."
                },
                "hints": {
                        "hint1": "Use a hashmap to count characters in chars.",
                        "hint2": "Check if each word can be formed using the available character counts."
                },
                "testCases": {
                        "test1": "Input: [\"cat\",\"bt\",\"hat\",\"tree\"], \"atach\" | Output: 6",
                        "test2": "Input: [\"hello\",\"world\",\"leetcode\"], \"welldonehoneyr\" | Output: 10",
                        "test3": "Input: [\"apple\",\"banana\"], \"abc\" | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int countCharacters(String[] words, String chars) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int countCharacters(std::vector<std::string>& words, std::string chars) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Largest 3-Same-Digit Number in String",
                "description": "Given a string num representing a large integer, return the largest three-digit substring where all three digits are the same. If no such substring exists, return an empty string.",
                "topic": "Strings",
                "subtopic": "Substring Search",
                "level": "Easy",
                "tags": ["string", "substring", "brute force"],
                "examples": {
                        "example1": "Input: num = \"6777133339\"\nOutput: \"777\"",
                        "example2": "Input: num = \"2300019\"\nOutput: \"000\""
                },
                "constraints": {
                        "constraint1": "3 <= num.length <= 1000",
                        "constraint2": "num consists of only digits (0-9)."
                },
                "hints": {
                        "hint1": "Use a loop to check every substring of length 3.",
                        "hint2": "Keep track of the largest valid substring encountered."
                },
                "testCases": {
                        "test1": "Input: \"6777133339\" | Output: \"777\"",
                        "test2": "Input: \"2300019\" | Output: \"000\"",
                        "test3": "Input: \"123456\" | Output: \"\""
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String largestGoodInteger(String num) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def largestGoodInteger(self, num: str) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\n\nclass Solution {\npublic:\n    std::string largestGoodInteger(std::string num) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Destination City",
                "description": "You are given a list of paths, where paths[i] = [cityA, cityB] means there exists a direct path from cityA to cityB. Return the destination city, which is the city that is not present as a starting city in any path.",
                "topic": "Graph",
                "subtopic": "Path Finding",
                "level": "Easy",
                "tags": ["graph", "hashmap", "pathfinding"],
                "examples": {
                        "example1": "Input: paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]\nOutput: \"Sao Paulo\"",
                        "example2": "Input: paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]\nOutput: \"A\""
                },
                "constraints": {
                        "constraint1": "1 <= paths.length <= 100",
                        "constraint2": "paths[i].length == 2",
                        "constraint3": "1 <= cityA.length, cityB.length <= 10",
                        "constraint4": "cityA != cityB",
                        "constraint5": "All paths are unique."
                },
                "hints": {
                        "hint1": "Use a hash set to store all starting cities.",
                        "hint2": "Find the city that does not appear as a starting city."
                },
                "testCases": {
                        "test1": "Input: [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]] | Output: \"Sao Paulo\"",
                        "test2": "Input: [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]] | Output: \"A\"",
                        "test3": "Input: [[\"X\",\"Y\"]] | Output: \"Y\""
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String destCity(List<List<String>> paths) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def destCity(self, paths: List[List[str]]) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::string destCity(std::vector<std::vector<std::string>>& paths) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Maximum Product Difference Between Two Pairs",
                "description": "Given an integer array nums, choose two pairs (a, b) and (c, d) such that their product difference is maximized. Return the maximum product difference, calculated as (a * b) - (c * d).",
                "topic": "Array",
                "subtopic": "Sorting",
                "level": "Easy",
                "tags": ["array", "sorting", "math"],
                "examples": {
                        "example1": "Input: nums = [5,6,2,7,4]\nOutput: 34",
                        "example2": "Input: nums = [4,2,5,9,7,4,8]\nOutput: 64"
                },
                "constraints": {
                        "constraint1": "4 <= nums.length <= 10^4",
                        "constraint2": "1 <= nums[i] <= 10^4"
                },
                "hints": {
                        "hint1": "Sort the array and use the largest two and smallest two numbers.",
                        "hint2": "Use the formula (max1 * max2) - (min1 * min2)."
                },
                "testCases": {
                        "test1": "Input: [5,6,2,7,4] | Output: 34",
                        "test2": "Input: [4,2,5,9,7,4,8] | Output: 64",
                        "test3": "Input: [1,2,3,4] | Output: 4"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int maxProductDifference(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def maxProductDifference(self, nums: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n\nclass Solution {\npublic:\n    int maxProductDifference(std::vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Maximum Score After Splitting a String",
                "description": "Given a binary string s, split it into two non-empty substrings such that the sum of the number of 0s in the left substring and the number of 1s in the right substring is maximized. Return the maximum possible score.",
                "topic": "Strings",
                "subtopic": "Prefix Sum",
                "level": "Easy",
                "tags": ["string", "prefix sum", "greedy"],
                "examples": {
                        "example1": "Input: s = \"011101\"\nOutput: 5",
                        "example2": "Input: s = \"00111\"\nOutput: 5"
                },
                "constraints": {
                        "constraint1": "2 <= s.length <= 500",
                        "constraint2": "s consists of only '0' and '1'."
                },
                "hints": {
                        "hint1": "Iterate through the string and count left 0s and right 1s.",
                        "hint2": "Keep track of the maximum score while iterating."
                },
                "testCases": {
                        "test1": "Input: \"011101\" | Output: 5",
                        "test2": "Input: \"00111\" | Output: 5",
                        "test3": "Input: \"1111\" | Output: 3"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int maxScore(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def maxScore(self, s: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\n\nclass Solution {\npublic:\n    int maxScore(std::string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Path Crossing",
                "description": "Given a string path representing the movement of a person in a 2D plane, return true if the path crosses itself, otherwise return false.",
                "topic": "HashSet",
                "subtopic": "Simulation",
                "level": "Easy",
                "tags": ["hashset", "simulation", "grid"],
                "examples": {
                        "example1": "Input: path = \"NES\"\nOutput: false",
                        "example2": "Input: path = \"NESWW\"\nOutput: true"
                },
                "constraints": {
                        "constraint1": "1 <= path.length <= 10^4",
                        "constraint2": "path consists of only 'N', 'S', 'E', 'W'."
                },
                "hints": {
                        "hint1": "Use a set to store visited coordinates.",
                        "hint2": "If a coordinate is visited again, return true."
                },
                "testCases": {
                        "test1": "Input: \"NES\" | Output: false",
                        "test2": "Input: \"NESWW\" | Output: true",
                        "test3": "Input: \"EESWWN\" | Output: false"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isPathCrossing(String path) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isPathCrossing(self, path: str) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\n\nclass Solution {\npublic:\n    bool isPathCrossing(std::string path) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Minimum Changes To Make Alternating Binary String",
                "description": "Given a binary string s, return the minimum number of operations needed to make the string alternating, where no two adjacent characters are the same.",
                "topic": "Strings",
                "subtopic": "Greedy",
                "level": "Easy",
                "tags": ["string", "greedy", "pattern"],
                "examples": {
                        "example1": "Input: s = \"0100\"\nOutput: 1",
                        "example2": "Input: s = \"1111\"\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 10^5",
                        "constraint2": "s consists of only '0' and '1'."
                },
                "hints": {
                        "hint1": "Consider both possible alternating patterns.",
                        "hint2": "Count mismatches for each pattern."
                },
                "testCases": {
                        "test1": "Input: \"0100\" | Output: 1",
                        "test2": "Input: \"1111\" | Output: 2",
                        "test3": "Input: \"101010\" | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int minOperations(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def minOperations(self, s: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\n\nclass Solution {\npublic:\n    int minOperations(std::string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Redistribute Characters to Make All Strings Equal",
                "description": "Given an array of strings words, determine if it's possible to redistribute the characters of the strings such that each string in words becomes identical.",
                "topic": "Strings",
                "subtopic": "HashMap",
                "level": "Easy",
                "tags": ["string", "hashmap", "frequency"],
                "examples": {
                        "example1": "Input: words = [\"abc\", \"aabc\", \"bc\"]\nOutput: true",
                        "example2": "Input: words = [\"ab\", \"a\"]\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= words.length <= 100",
                        "constraint2": "1 <= words[i].length <= 100",
                        "constraint3": "words[i] consists of lowercase English letters."
                },
                "hints": {
                        "hint1": "Count the frequency of each character in all words.",
                        "hint2": "Check if all character frequencies can be evenly distributed among all words."
                },
                "testCases": {
                        "test1": "Input: [\"abc\", \"aabc\", \"bc\"] | Output: true",
                        "test2": "Input: [\"ab\", \"a\"] | Output: false",
                        "test3": "Input: [\"aa\", \"bb\", \"ab\"] | Output: false"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean makeEqual(String[] words) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def makeEqual(self, words: List[str]) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    bool makeEqual(std::vector<std::string>& words) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Largest Substring Between Two Equal Characters",
                "description": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters themselves.",
                "topic": "Strings",
                "subtopic": "HashMap",
                "level": "Easy",
                "tags": ["string", "hashmap", "indices"],
                "examples": {
                        "example1": "Input: s = \"abca\"\nOutput: 2",
                        "example2": "Input: s = \"cbzxy\"\nOutput: -1"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 1000",
                        "constraint2": "s consists of only lowercase English letters."
                },
                "hints": {
                        "hint1": "Store the first and last occurrence of each character.",
                        "hint2": "Compute the difference between positions to find the largest gap."
                },
                "testCases": {
                        "test1": "Input: \"abca\" | Output: 2",
                        "test2": "Input: \"cbzxy\" | Output: -1",
                        "test3": "Input: \"aa\" | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int maxLengthBetweenEqualCharacters(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def maxLengthBetweenEqualCharacters(self, s: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\n\nclass Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(std::string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Set Mismatch",
                "description": "You have a set of numbers from 1 to n. However, one number is duplicated, and another is missing. Find and return the duplicate number and the missing number.",
                "topic": "Array",
                "subtopic": "Sorting, Hashing",
                "level": "Easy",
                "tags": ["array", "hashmap", "sorting"],
                "examples": {
                        "example1": "Input: nums = [1,2,2,4]\nOutput: [2,3]",
                        "example2": "Input: nums = [1,1]\nOutput: [1,2]"
                },
                "constraints": {
                        "constraint1": "2 <= nums.length <= 10^4",
                        "constraint2": "1 <= nums[i] <= nums.length"
                },
                "hints": {
                        "hint1": "Use a frequency map to find the duplicate number.",
                        "hint2": "Find the missing number by checking the expected sum."
                },
                "testCases": {
                        "test1": "Input: [1,2,2,4] | Output: [2,3]",
                        "test2": "Input: [1,1] | Output: [1,2]",
                        "test3": "Input: [2,2] | Output: [2,1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] findErrorNums(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> findErrorNums(std::vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "First Unique Character in a String",
                "description": "Given a string s, find the first non-repeating character and return its index. If there is no unique character, return -1.",
                "topic": "Strings",
                "subtopic": "Hashing",
                "level": "Easy",
                "tags": ["string", "hashmap", "frequency"],
                "examples": {
                        "example1": "Input: s = \"leetcode\"\nOutput: 0",
                        "example2": "Input: s = \"loveleetcode\"\nOutput: 2",
                        "example3": "Input: s = \"aabb\"\nOutput: -1"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 10^5",
                        "constraint2": "s consists of only lowercase English letters."
                },
                "hints": {
                        "hint1": "Use a frequency map to count occurrences of each character.",
                        "hint2": "Iterate through the string to find the first character with a count of 1."
                },
                "testCases": {
                        "test1": "Input: \"leetcode\" | Output: 0",
                        "test2": "Input: \"loveleetcode\" | Output: 2",
                        "test3": "Input: \"aabb\" | Output: -1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int firstUniqChar(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def firstUniqChar(self, s: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\n\nclass Solution {\npublic:\n    int firstUniqChar(std::string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Intersection of Two Array",
                "description": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and may be returned in any order.",
                "topic": "Array",
                "subtopic": "Hashing, Two Pointers",
                "level": "Easy",
                "tags": ["array", "hashset", "sorting"],
                "examples": {
                        "example1": "Input: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]",
                        "example2": "Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4] or [4,9]"
                },
                "constraints": {
                        "constraint1": "1 <= nums1.length, nums2.length <= 1000",
                        "constraint2": "0 <= nums1[i], nums2[i] <= 1000"
                },
                "hints": {
                        "hint1": "Use a hash set to store elements from one array.",
                        "hint2": "Check which elements appear in both arrays."
                },
                "testCases": {
                        "test1": "Input: [1,2,2,1], [2,2] | Output: [2]",
                        "test2": "Input: [4,9,5], [9,4,9,8,4] | Output: [9,4] or [4,9]",
                        "test3": "Input: [1,2,3], [4,5,6] | Output: []"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> intersection(std::vector<int>& nums1, std::vector<int>& nums2) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Number of Students Unable to Eat Lunch",
                "description": "There are n students in a queue. Each student prefers either a circular sandwich (0) or a square sandwich (1). The sandwiches are stacked in a way that the topmost sandwich must be taken first. If a student refuses to take a sandwich, they go to the end of the line. Determine the number of students who are unable to eat.",
                "topic": "Queue",
                "subtopic": "Simulation",
                "level": "Easy",
                "tags": ["queue", "simulation", "array"],
                "examples": {
                        "example1": "Input: students = [1,1,0,0], sandwiches = [0,1,0,1]\nOutput: 0",
                        "example2": "Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\nOutput: 3"
                },
                "constraints": {
                        "constraint1": "1 <= students.length, sandwiches.length <= 100",
                        "constraint2": "students[i] is either 0 or 1.",
                        "constraint3": "sandwiches[i] is either 0 or 1."
                },
                "hints": {
                        "hint1": "Use a queue to simulate the process.",
                        "hint2": "Check if a student is stuck in an infinite loop where they never get their preferred sandwich."
                },
                "testCases": {
                        "test1": "Input: [1,1,0,0], [0,1,0,1] | Output: 0",
                        "test2": "Input: [1,1,1,0,0,1], [1,0,0,0,1,1] | Output: 3",
                        "test3": "Input: [0,0,1,1], [1,0,0,1] | Output: 0"
                },
                "codeSnippets": {
                        "java": "import java.util.*;\nclass Solution {\n    public int countStudents(int[] students, int[] sandwiches) {\n        // Write your code here\n    }\n}",
                        "python": "from collections import deque\nclass Solution:\n    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <queue>\n\nclass Solution {\npublic:\n    int countStudents(std::vector<int>& students, std::vector<int>& sandwiches) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Time Needed to Buy Tickets",
                "description": "There are n people in a queue, and each person wants to buy tickets. The ith person needs tickets[i] tickets. Each person buys one ticket per second in a circular fashion. Return the time taken for the kth person to finish buying their tickets.",
                "topic": "Queues",
                "subtopic": "Simulation",
                "level": "Easy",
                "tags": ["queue", "simulation", "array"],
                "examples": {
                        "example1": "Input: tickets = [2,3,2], k = 2\nOutput: 6",
                        "example2": "Input: tickets = [5,1,1,1], k = 0\nOutput: 8"
                },
                "constraints": {
                        "constraint1": "n == tickets.length",
                        "constraint2": "1 <= n <= 100",
                        "constraint3": "1 <= tickets[i] <= 100",
                        "constraint4": "0 <= k < n"
                },
                "hints": {
                        "hint1": "Simulate the ticket buying process using a queue.",
                        "hint2": "Count the total time until the kth person completes their tickets."
                },
                "testCases": {
                        "test1": "Input: [2,3,2], 2 | Output: 6",
                        "test2": "Input: [5,1,1,1], 0 | Output: 8",
                        "test3": "Input: [1,1,1,1], 2 | Output: 3"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int timeRequiredToBuy(int[] tickets, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n\nclass Solution {\npublic:\n    int timeRequiredToBuy(std::vector<int>& tickets, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Special Array with X Elements Greater than or Equal to X",
                "description": "You are given an array nums of non-negative integers. You need to determine if there exists a number x such that there are exactly x elements in nums that are greater than or equal to x.",
                "topic": "Sorting",
                "subtopic": "Binary Search",
                "level": "Medium",
                "tags": ["sorting", "binary search", "greedy"],
                "examples": {
                        "example1": "Input: nums = [3,5]\nOutput: 2",
                        "example2": "Input: nums = [0,0]\nOutput: -1",
                        "example3": "Input: nums = [0,4,3,0,4]\nOutput: 3"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 100",
                        "constraint2": "0 <= nums[i] <= 1000"
                },
                "hints": {
                        "hint1": "Sort the array and check each possible x.",
                        "hint2": "Binary search can help optimize the approach."
                },
                "testCases": {
                        "test1": "Input: [3,5] | Output: 2",
                        "test2": "Input: [0,0] | Output: -1",
                        "test3": "Input: [0,4,3,0,4] | Output: 3"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int specialArray(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def specialArray(self, nums: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n\nclass Solution {\npublic:\n    int specialArray(std::vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Sort an Array",
                "description": "Given an array of integers nums, sort the array in ascending order.",
                "topic": "Sorting",
                "subtopic": "Merge Sort, Quick Sort",
                "level": "Medium",
                "tags": ["sorting", "merge sort", "quick sort"],
                "examples": {
                        "example1": "Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]",
                        "example2": "Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 50000",
                        "constraint2": "-5 * 10^4 <= nums[i] <= 5 * 10^4"
                },
                "hints": {
                        "hint1": "Try using merge sort or quick sort for optimal performance.",
                        "hint2": "Sorting algorithms with O(n log n) complexity are preferred."
                },
                "testCases": {
                        "test1": "Input: [5,2,3,1] | Output: [1,2,3,5]",
                        "test2": "Input: [5,1,1,2,0,0] | Output: [0,0,1,1,2,5]",
                        "test3": "Input: [3,2,1] | Output: [1,2,3]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] sortArray(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> sortArray(std::vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Sort Colors",
                "description": "Given an array nums with n objects colored red, white, or blue (represented by 0, 1, and 2), sort them in-place so that objects of the same color are adjacent, in the order red, white, and blue.",
                "topic": "Sorting",
                "subtopic": "Two Pointers",
                "level": "Medium",
                "tags": ["sorting", "two pointers", "array"],
                "examples": {
                        "example1": "Input: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]",
                        "example2": "Input: nums = [2,0,1]\nOutput: [0,1,2]"
                },
                "constraints": {
                        "constraint1": "n == nums.length",
                        "constraint2": "1 <= n <= 300",
                        "constraint3": "nums[i] is 0, 1, or 2"
                },
                "hints": {
                        "hint1": "Use a two-pointer approach to swap elements in place.",
                        "hint2": "Dutch National Flag algorithm can solve it optimally."
                },
                "testCases": {
                        "test1": "Input: [2,0,2,1,1,0] | Output: [0,0,1,1,2,2]",
                        "test2": "Input: [2,0,1] | Output: [0,1,2]",
                        "test3": "Input: [0] | Output: [0]",
                        "test4": "Input: [1] | Output: [1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void sortColors(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n\nclass Solution {\npublic:\n    void sortColors(std::vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Encode and Decode Strings",
                "description": "Design an algorithm to encode a list of strings into a single string. Implement a decode method that reverses the encoding.",
                "topic": "String",
                "subtopic": "Encoding/Decoding",
                "level": "Medium",
                "tags": ["string", "design", "encoding", "decoding"],
                "examples": {
                        "example1": "Input: ['hello', 'world']\nEncoded: '5#hello5#world'\nDecoded: ['hello', 'world']",
                        "example2": "Input: ['']\nEncoded: '0#'\nDecoded: ['']"
                },
                "constraints": {
                        "constraint1": "The number of strings is at most 1000",
                        "constraint2": "Each string's length is at most 200",
                        "constraint3": "Strings consist of printable ASCII characters"
                },
                "hints": {
                        "hint1": "Use a delimiter to separate strings, ensuring it doesn’t conflict with string content.",
                        "hint2": "Store the length of each string before the actual content."
                },
                "testCases": {
                        "test1": "Input: ['hello', 'world'] | Output: Encoded: '5#hello5#world', Decoded: ['hello', 'world']",
                        "test2": "Input: [''] | Output: Encoded: '0#', Decoded: ['']",
                        "test3": "Input: ['a', 'bb', 'ccc'] | Output: Encoded: '1#a2#bb3#ccc', Decoded: ['a', 'bb', 'ccc']"
                },
                "codeSnippets": {
                        "java": "class Codec {\n    public String encode(List<String> strs) {\n        // Write your code here\n    }\n    public List<String> decode(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Codec:\n    def encode(self, strs: List[str]) -> str:\n        # Write your code here\n        pass\n    def decode(self, s: str) -> List[str]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\n\nclass Codec {\npublic:\n    std::string encode(std::vector<std::string>& strs) {\n        // Write your code here\n    }\n    std::vector<std::string> decode(std::string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Range Sum Query 2D - Immutable",
                "description": "Given a 2D matrix, calculate the sum of the elements in a given submatrix efficiently.",
                "topic": "Dynamic Programming",
                "subtopic": "Prefix Sum",
                "level": "Medium",
                "tags": ["matrix", "prefix sum", "dynamic programming"],
                "examples": {
                        "example1": "Input: matrix = [[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]], row1 = 2, col1 = 1, row2 = 4, col2 = 3\nOutput: 8",
                        "example2": "Input: matrix = [[2,4,3],[1,5,7],[6,8,9]], row1 = 1, col1 = 1, row2 = 2, col2 = 2\nOutput: 29"
                },
                "constraints": {
                        "constraint1": "1 <= matrix.length, matrix[0].length <= 200",
                        "constraint2": "-10^5 <= matrix[i][j] <= 10^5",
                        "constraint3": "Queries are within valid matrix bounds"
                },
                "hints": {
                        "hint1": "Precompute the prefix sum for fast queries.",
                        "hint2": "Use the difference of precomputed sums for efficient range sum calculation."
                },
                "testCases": {
                        "test1": "Input: [[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]], 2,1,4,3 | Output: 8",
                        "test2": "Input: [[2,4,3],[1,5,7],[6,8,9]], 1,1,2,2 | Output: 29"
                },
                "codeSnippets": {
                        "java": "class NumMatrix {\n    public NumMatrix(int[][] matrix) {\n        // Write your code here\n    }\n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        // Write your code here\n    }\n}",
                        "python": "class NumMatrix:\n    def __init__(self, matrix: List[List[int]]):\n        # Write your code here\n        pass\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n\nclass NumMatrix {\npublic:\n    NumMatrix(std::vector<std::vector<int>>& matrix) {\n        // Write your code here\n    }\n    int sumRegion(int row1, int col1, int row2, int col2) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Product of Array Except Self",
                "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
                "topic": "Array",
                "subtopic": "Prefix and Suffix Product",
                "level": "Medium",
                "tags": ["array", "product", "prefix", "suffix"],
                "examples": {
                        "example1": "Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]",
                        "example2": "Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]"
                },
                "constraints": {
                        "constraint1": "2 <= nums.length <= 10^5",
                        "constraint2": "-30 <= nums[i] <= 30",
                        "constraint3": "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."
                },
                "hints": {
                        "hint1": "Try to solve the problem without using division.",
                        "hint2": "Use prefix and suffix products to calculate the result."
                },
                "testCases": {
                        "test1": "Input: [1,2,3,4] | Output: [24,12,8,6]",
                        "test2": "Input: [-1,1,0,-3,3] | Output: [0,0,9,0,0]",
                        "test3": "Input: [2,3,4,5] | Output: [60,40,30,24]",
                        "test4": "Input: [10,5,2] | Output: [10,20,50]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Valid Sudoku",
                "description": "Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to Sudoku rules.",
                "topic": "Matrix",
                "subtopic": "Hashing",
                "level": "Medium",
                "tags": ["matrix", "hashing", "sudoku"],
                "examples": {
                        "example1": "Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n                 [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n                 [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n                 [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n                 [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n                 [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n                 [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n                 [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n                 [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true"
                },
                "constraints": {
                        "constraint1": "Each row must contain the digits 1-9 without repetition.",
                        "constraint2": "Each column must contain the digits 1-9 without repetition.",
                        "constraint3": "Each 3x3 sub-box must contain the digits 1-9 without repetition."
                },
                "hints": {
                        "hint1": "Use a hash set to track seen numbers.",
                        "hint2": "Iterate through the board while checking rows, columns, and 3x3 grids."
                },
                "testCases": {
                        "test1": "Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n                 [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n                 [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n                 [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n                 [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n                 [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n                 [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n                 [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n                 [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\nclass Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>>& board) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Longest Consecutive Sequence",
                "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.",
                "topic": "Array",
                "subtopic": "Sorting & Hashing",
                "level": "Medium",
                "tags": ["array", "hashing", "sorting"],
                "examples": {
                        "example1": "Input: nums = [100,4,200,1,3,2]\nOutput: 4",
                        "example2": "Input: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9"
                },
                "constraints": {
                        "constraint1": "0 <= nums.length <= 10^5",
                        "constraint2": "-10^9 <= nums[i] <= 10^9"
                },
                "hints": {
                        "hint1": "Can you solve it using sorting?",
                        "hint2": "Try using a HashSet to check for consecutive elements."
                },
                "testCases": {
                        "test1": "Input: [100,4,200,1,3,2] | Output: 4",
                        "test2": "Input: [0,3,7,2,5,8,4,6,0,1] | Output: 9",
                        "test3": "Input: [1,2,0,1] | Output: 3"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Encode and Decode TinyURL",
                "description": "Design a system that encodes a URL into a shortened URL and decodes the shortened URL back to the original URL.",
                "topic": "Design",
                "subtopic": "Hashing",
                "level": "Medium",
                "tags": ["hashing", "design", "string"],
                "examples": {
                        "example1": "Input: url = 'https://example.com'\nOutput: short_url = 'http://tinyurl.com/abc123'\nDecoding short_url should return 'https://example.com'"
                },
                "constraints": {
                        "constraint1": "The length of the URL does not exceed 2048 characters.",
                        "constraint2": "The encoded URL should be unique for different URLs."
                },
                "hints": {
                        "hint1": "Use a hash function or random string generation for encoding.",
                        "hint2": "Store a mapping between short and original URLs."
                },
                "testCases": {
                        "test1": "Input: 'https://example.com' | Output: 'http://tinyurl.com/abc123'",
                        "test2": "Input: 'https://leetcode.com/problems' | Output: 'http://tinyurl.com/xyz789'",
                        "test3": "Decoding 'http://tinyurl.com/abc123' should return 'https://example.com'"
                },
                "codeSnippets": {
                        "java": "class Codec {\n    public String encode(String longUrl) {\n        // Write your code here\n    }\n    public String decode(String shortUrl) {\n        // Write your code here\n    }\n}",
                        "python": "class Codec:\n    def encode(self, longUrl: str) -> str:\n        # Write your code here\n        pass\n    def decode(self, shortUrl: str) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\n\nclass Codec {\npublic:\n    std::string encode(std::string longUrl) {\n        // Write your code here\n    }\n    std::string decode(std::string shortUrl) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Brick Wall",
                "description": "Given a list of lists representing a brick wall, find the least number of bricks you must cross if you draw a vertical line through the wall.",
                "topic": "Hashing",
                "subtopic": "Prefix Sum",
                "level": "Medium",
                "tags": ["hashing", "prefix sum"],
                "examples": {
                        "example1": "Input: [[1,2,2,1], [3,1,2], [1,3,2], [2,4], [3,1,2], [1,3,1,1]]\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "1 <= number of rows <= 10^4",
                        "constraint2": "Sum of bricks in any row is the same."
                },
                "hints": {
                        "hint1": "Track where the gaps between bricks occur.",
                        "hint2": "Use a hashmap to count frequencies of gaps."
                },
                "testCases": {
                        "test1": "Input: [[1,2,2,1], [3,1,2], [1,3,2], [2,4], [3,1,2], [1,3,1,1]] | Output: 2",
                        "test2": "Input: [[1], [1], [1]] | Output: 3"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int leastBricks(List<List<Integer>> wall) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def leastBricks(self, wall: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int leastBricks(vector<vector<int>>& wall) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Best Time to Buy and Sell Stock II",
                "description": "Given an array prices where prices[i] is the price of a given stock on the ith day, return the maximum profit you can achieve by buying and selling stocks multiple times.",
                "topic": "Dynamic Programming",
                "subtopic": "Greedy",
                "level": "Medium",
                "tags": ["array", "greedy", "dp"],
                "examples": {
                        "example1": "Input: prices = [7,1,5,3,6,4]\nOutput: 7",
                        "example2": "Input: prices = [1,2,3,4,5]\nOutput: 4"
                },
                "constraints": {
                        "constraint1": "1 <= prices.length <= 3 * 10^4",
                        "constraint2": "0 <= prices[i] <= 10^4"
                },
                "hints": {
                        "hint1": "Think about how to maximize profit using multiple transactions.",
                        "hint2": "You only gain profit when a price increases."
                },
                "testCases": {
                        "test1": "Input: [7,1,5,3,6,4] | Output: 7",
                        "test2": "Input: [1,2,3,4,5] | Output: 4",
                        "test3": "Input: [7,6,4,3,1] | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int maxProfit(int[] prices) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Majority Element II",
                "description": "Given an integer array nums, return all elements that appear more than ⌊n/3⌋ times.",
                "topic": "Array",
                "subtopic": "Boyer-Moore Voting Algorithm",
                "level": "Medium",
                "tags": ["array", "hashmap", "Boyer-Moore"],
                "examples": {
                        "example1": "Input: nums = [3,2,3]\nOutput: [3]",
                        "example2": "Input: nums = [1,1,1,3,3,2,2,2]\nOutput: [1,2]"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 5 * 10^4",
                        "constraint2": "-10^9 <= nums[i] <= 10^9"
                },
                "hints": {
                        "hint1": "A number appearing more than ⌊n/3⌋ times can be at most two numbers.",
                        "hint2": "Use Boyer-Moore Voting Algorithm to find potential candidates."
                },
                "testCases": {
                        "test1": "Input: [3,2,3] | Output: [3]",
                        "test2": "Input: [1,1,1,3,3,2,2,2] | Output: [1,2]",
                        "test3": "Input: [2,2,9,3,9,3,9,3,9,3,9,3,9,9] | Output: [3,9]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> majorityElement(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Subarray Sum Equals K",
                "description": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals k.",
                "topic": "Array",
                "subtopic": "Prefix Sum",
                "level": "Medium",
                "tags": ["array", "prefix sum", "hashmap"],
                "examples": {
                        "example1": "Input: nums = [1,1,1], k = 2\nOutput: 2",
                        "example2": "Input: nums = [1,2,3], k = 3\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 2 * 10^4",
                        "constraint2": "-1000 <= nums[i] <= 1000",
                        "constraint3": "-10^7 <= k <= 10^7"
                },
                "hints": {
                        "hint1": "Use a prefix sum and a hashmap to keep track of the occurrences of sums.",
                        "hint2": "If prefix_sum[j] - prefix_sum[i] == k, then subarray [i+1, j] has sum k."
                },
                "testCases": {
                        "test1": "Input: [1,1,1], k = 2 | Output: 2",
                        "test2": "Input: [1,2,3], k = 3 | Output: 2",
                        "test3": "Input: [1,-1,0], k = 0 | Output: 3"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int subarraySum(int[] nums, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Unique Length 3 Palindromic Subsequences",
                "description": "Given a string s, return the number of unique palindromic subsequences of length 3.",
                "topic": "Strings",
                "subtopic": "Two Pointers",
                "level": "Medium",
                "tags": ["string", "palindrome", "hashing"],
                "examples": {
                        "example1": "Input: s = 'aabca'\nOutput: 3",
                        "example2": "Input: s = 'adc'\nOutput: 0"
                },
                "constraints": {
                        "constraint1": "3 <= s.length <= 10^5",
                        "constraint2": "s consists only of lowercase English letters."
                },
                "hints": {
                        "hint1": "Look for unique characters in the first and last position.",
                        "hint2": "Use a set to track valid middle characters."
                },
                "testCases": {
                        "test1": "Input: 'aabca' | Output: 3",
                        "test2": "Input: 'adc' | Output: 0",
                        "test3": "Input: 'bbcbaba' | Output: 4"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int countPalindromicSubsequence(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def countPalindromicSubsequence(self, s: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int countPalindromicSubsequence(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Minimum Number of Swaps to Make The String Balanced",
                "description": "Given a string s of length n consisting only of '[' and ']', return the minimum number of swaps to make the string balanced.",
                "topic": "Strings",
                "subtopic": "Greedy",
                "level": "Medium",
                "tags": ["string", "greedy", "stack"],
                "examples": {
                        "example1": "Input: s = ']]][[['\nOutput: 2",
                        "example2": "Input: s = '[]'\nOutput: 0"
                },
                "constraints": {
                        "constraint1": "n is even",
                        "constraint2": "2 <= n <= 10^6",
                        "constraint3": "s consists only of '[' and ']'"
                },
                "hints": {
                        "hint1": "Track the balance of '[' and ']' to find mismatches.",
                        "hint2": "Use a greedy approach to swap misplaced brackets."
                },
                "testCases": {
                        "test1": "Input: ']]][[[' | Output: 2",
                        "test2": "Input: '[]' | Output: 0",
                        "test3": "Input: '][' | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int minSwaps(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def minSwaps(self, s: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minSwaps(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Number of Pairs of Interchangeable Rectangles",
                "description": "Given a list of rectangles represented as [width, height], return the number of pairs (i, j) such that the rectangles are interchangeable.",
                "topic": "Hashing",
                "subtopic": "Ratios",
                "level": "Medium",
                "tags": ["hashmap", "math", "geometry"],
                "examples": {
                        "example1": "Input: rectangles = [[4,8],[3,6],[10,20],[15,30]]\nOutput: 6",
                        "example2": "Input: rectangles = [[4,5],[7,8]]\nOutput: 0"
                },
                "constraints": {
                        "constraint1": "1 <= rectangles.length <= 10^5",
                        "constraint2": "1 <= width, height <= 10^9"
                },
                "hints": {
                        "hint1": "Use the width-to-height ratio to determine interchangeability.",
                        "hint2": "Store ratios in a hashmap and count pairs."
                },
                "testCases": {
                        "test1": "Input: [[4,8],[3,6],[10,20],[15,30]] | Output: 6",
                        "test2": "Input: [[4,5],[7,8]] | Output: 0",
                        "test3": "Input: [[5,10],[10,20],[10,10]] | Output: 3"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int interchangeableRectangles(int[][] rectangles) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int interchangeableRectangles(vector<vector<int>>& rectangles) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Maximum Product of The Length of Two Palindromic Subsequences",
                "description": "Given a string s, find two non-overlapping palindromic subsequences such that their product of lengths is maximized.",
                "topic": "Dynamic Programming",
                "subtopic": "Bitmask DP",
                "level": "Hard",
                "tags": ["string", "bitmask", "palindrome"],
                "examples": {
                        "example1": "Input: s = 'ababbb'\nOutput: 9",
                        "example2": "Input: s = 'zaaaxbbby'\nOutput: 9"
                },
                "constraints": {
                        "constraint1": "2 <= s.length <= 12",
                        "constraint2": "s consists only of lowercase English letters."
                },
                "hints": {
                        "hint1": "Use a bitmask to generate all possible subsequences.",
                        "hint2": "Check if a subsequence is a palindrome efficiently."
                },
                "testCases": {
                        "test1": "Input: 'ababbb' | Output: 9",
                        "test2": "Input: 'zaaaxbbby' | Output: 9",
                        "test3": "Input: 'abc' | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int maxProduct(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def maxProduct(self, s: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxProduct(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Minimum Number of Swaps to Make The String Balanced",
                "description": "Given a string s of length n consisting only of '[' and ']', return the minimum number of swaps to make the string balanced.",
                "topic": "Strings",
                "subtopic": "Greedy",
                "level": "Medium",
                "tags": ["string", "greedy", "stack"],
                "examples": {
                        "example1": "Input: s = ']]][[['\nOutput: 2",
                        "example2": "Input: s = '[]'\nOutput: 0"
                },
                "constraints": {
                        "constraint1": "n is even",
                        "constraint2": "2 <= n <= 10^6",
                        "constraint3": "s consists only of '[' and ']'"
                },
                "hints": {
                        "hint1": "Track the balance of '[' and ']' to find mismatches.",
                        "hint2": "Use a greedy approach to swap misplaced brackets."
                },
                "testCases": {
                        "test1": "Input: ']]][[[' | Output: 2",
                        "test2": "Input: '[]' | Output: 0",
                        "test3": "Input: '][' | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int minSwaps(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def minSwaps(self, s: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minSwaps(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Number of Pairs of Interchangeable Rectangles",
                "description": "Given a list of rectangles represented as [width, height], return the number of pairs (i, j) such that the rectangles are interchangeable.",
                "topic": "Hashing",
                "subtopic": "Ratios",
                "level": "Medium",
                "tags": ["hashmap", "math", "geometry"],
                "examples": {
                        "example1": "Input: rectangles = [[4,8],[3,6],[10,20],[15,30]]\nOutput: 6",
                        "example2": "Input: rectangles = [[4,5],[7,8]]\nOutput: 0"
                },
                "constraints": {
                        "constraint1": "1 <= rectangles.length <= 10^5",
                        "constraint2": "1 <= width, height <= 10^9"
                },
                "hints": {
                        "hint1": "Use the width-to-height ratio to determine interchangeability.",
                        "hint2": "Store ratios in a hashmap and count pairs."
                },
                "testCases": {
                        "test1": "Input: [[4,8],[3,6],[10,20],[15,30]] | Output: 6",
                        "test2": "Input: [[4,5],[7,8]] | Output: 0",
                        "test3": "Input: [[5,10],[10,20],[10,10]] | Output: 3"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int interchangeableRectangles(int[][] rectangles) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int interchangeableRectangles(vector<vector<int>>& rectangles) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Maximum Product of The Length of Two Palindromic Subsequences",
                "description": "Given a string s, find two non-overlapping palindromic subsequences such that their product of lengths is maximized.",
                "topic": "Dynamic Programming",
                "subtopic": "Bitmask DP",
                "level": "Hard",
                "tags": ["string", "bitmask", "palindrome"],
                "examples": {
                        "example1": "Input: s = 'ababbb'\nOutput: 9",
                        "example2": "Input: s = 'zaaaxbbby'\nOutput: 9"
                },
                "constraints": {
                        "constraint1": "2 <= s.length <= 12",
                        "constraint2": "s consists only of lowercase English letters."
                },
                "hints": {
                        "hint1": "Use a bitmask to generate all possible subsequences.",
                        "hint2": "Check if a subsequence is a palindrome efficiently."
                },
                "testCases": {
                        "test1": "Input: 'ababbb' | Output: 9",
                        "test2": "Input: 'zaaaxbbby' | Output: 9",
                        "test3": "Input: 'abc' | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int maxProduct(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def maxProduct(self, s: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxProduct(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Wiggle Sort",
                "description": "Given an integer array nums, rearrange it so that nums[0] <= nums[1] >= nums[2] <= nums[3]... and so on.",
                "topic": "Sorting",
                "subtopic": "Greedy",
                "level": "Medium",
                "tags": ["array", "sorting", "greedy"],
                "examples": {
                        "example1": "Input: nums = [3, 5, 2, 1, 6, 4]\nOutput: [3, 5, 1, 6, 2, 4]",
                        "example2": "Input: nums = [6, 6, 5, 6]\nOutput: [5, 6, 6, 6]"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^5",
                        "constraint2": "0 <= nums[i] <= 10^9"
                },
                "hints": {
                        "hint1": "Consider sorting the array and swapping adjacent elements.",
                        "hint2": "Try a one-pass solution by modifying the array in-place."
                },
                "testCases": {
                        "test1": "Input: [3, 5, 2, 1, 6, 4] | Output: [3, 5, 1, 6, 2, 4]",
                        "test2": "Input: [6, 6, 5, 6] | Output: [5, 6, 6, 6]",
                        "test3": "Input: [1, 2, 3] | Output: [1, 3, 2]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void wiggleSort(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def wiggleSort(self, nums: List[int]) -> None:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    void wiggleSort(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Largest Number",
                "description": "Given a list of non-negative integers, arrange them to form the largest possible number.",
                "topic": "Sorting",
                "subtopic": "Custom Sorting",
                "level": "Medium",
                "tags": ["sorting", "greedy", "string"],
                "examples": {
                        "example1": "Input: nums = [10, 2]\nOutput: '210'",
                        "example2": "Input: nums = [3, 30, 34, 5, 9]\nOutput: '9534330'"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 100",
                        "constraint2": "0 <= nums[i] <= 10^9"
                },
                "hints": {
                        "hint1": "Compare numbers as strings in a custom order.",
                        "hint2": "Concatenate numbers and sort based on lexicographical order."
                },
                "testCases": {
                        "test1": "Input: [10, 2] | Output: '210'",
                        "test2": "Input: [3, 30, 34, 5, 9] | Output: '9534330'",
                        "test3": "Input: [1, 20, 23, 4, 8] | Output: '8423201'"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String largestNumber(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string largestNumber(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Continuous Subarray Sum",
                "description": "Given an integer array nums and an integer k, return true if nums has a contiguous subarray of size at least two whose elements sum up to a multiple of k.",
                "topic": "Prefix Sum",
                "subtopic": "Hashing",
                "level": "Medium",
                "tags": ["array", "prefix sum", "hashmap"],
                "examples": {
                        "example1": "Input: nums = [23, 2, 4, 6, 7], k = 6\nOutput: true",
                        "example2": "Input: nums = [23, 2, 6, 4, 7], k = 13\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^5",
                        "constraint2": "0 <= nums[i] <= 10^9",
                        "constraint3": "0 <= k <= 10^9"
                },
                "hints": {
                        "hint1": "Use prefix sums and store their remainders modulo k.",
                        "hint2": "Check for repeated remainders in a hashmap."
                },
                "testCases": {
                        "test1": "Input: [23, 2, 4, 6, 7], 6 | Output: true",
                        "test2": "Input: [23, 2, 6, 4, 7], 13 | Output: false",
                        "test3": "Input: [1, 2, 3], 5 | Output: false"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def checkSubarraySum(self, nums: List[int], k: int) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool checkSubarraySum(vector<int>& nums, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Push Dominoes",
                "description": "There are n dominoes in a line, and each domino can be pushed to the left ('L'), to the right ('R'), or left standing ('.'). Given a string representing the initial state, return the final state after all the dominoes have fallen.",
                "topic": "Simulation",
                "subtopic": "String Manipulation",
                "level": "Medium",
                "tags": ["simulation", "string", "two pointers"],
                "examples": {
                        "example1": "Input: dominoes = 'RR.L'\nOutput: 'RR.L'",
                        "example2": "Input: dominoes = '.L.R...LR..L..'\nOutput: 'LL.RR.LLRRLL..'"
                },
                "constraints": {
                        "constraint1": "1 <= dominoes.length <= 10^5",
                        "constraint2": "dominoes[i] is 'L', 'R', or '.'"
                },
                "hints": {
                        "hint1": "Consider the effect of forces applied from left and right separately.",
                        "hint2": "Use an array to track the net force on each domino."
                },
                "testCases": {
                        "test1": "Input: 'RR.L' | Output: 'RR.L'",
                        "test2": "Input: '.L.R...LR..L..' | Output: 'LL.RR.LLRRLL..'",
                        "test3": "Input: '...' | Output: '...'"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String pushDominoes(String dominoes) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def pushDominoes(self, dominoes: str) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Repeated DNA Sequences",
                "description": "Given a string s representing a DNA sequence, return all 10-letter-long sequences that appear more than once in s.",
                "topic": "Hashing",
                "subtopic": "Sliding Window",
                "level": "Medium",
                "tags": ["hashing", "bit manipulation", "sliding window"],
                "examples": {
                        "example1": "Input: s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'\nOutput: ['AAAAACCCCC', 'CCCCCAAAAA']",
                        "example2": "Input: s = 'AAAAAAAAAAAAA'\nOutput: ['AAAAAAAAAA']"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 10^5",
                        "constraint2": "s[i] is 'A', 'C', 'G', or 'T'"
                },
                "hints": {
                        "hint1": "Use a hash set to track seen sequences.",
                        "hint2": "Bit manipulation can optimize space usage."
                },
                "testCases": {
                        "test1": "Input: 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT' | Output: ['AAAAACCCCC', 'CCCCCAAAAA']",
                        "test2": "Input: 'AAAAAAAAAAAAA' | Output: ['AAAAAAAAAA']",
                        "test3": "Input: 'ACGTACGTACGT' | Output: []"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findRepeatedDnaSequences(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Insert Delete Get Random O(1)",
                "description": "Implement a data structure that supports insert, delete, and getRandom in average O(1) time complexity.",
                "topic": "Data Structures",
                "subtopic": "Hashing",
                "level": "Medium",
                "tags": ["hashmap", "randomization", "design"],
                "examples": {
                        "example1": "Input: [\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], []]\nOutput: [null, true, false, true, 1]",
                        "example2": "Input: [\"RandomizedSet\", \"insert\", \"insert\", \"remove\", \"getRandom\"]\n[[], [1], [2], [1], []]\nOutput: [null, true, true, true, 2]"
                },
                "constraints": {
                        "constraint1": "At most 2 * 10^5 calls will be made to insert, remove, and getRandom.",
                        "constraint2": "-10^9 <= val <= 10^9"
                },
                "hints": {
                        "hint1": "Use a hashmap for quick lookup and an array for random access.",
                        "hint2": "To delete in O(1), swap the last element with the deleted element."
                },
                "testCases": {
                        "test1": "Input: [\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], []] | Output: [null, true, false, true, 1]",
                        "test2": "Input: [\"RandomizedSet\", \"insert\", \"insert\", \"remove\", \"getRandom\"]\n[[], [1], [2], [1], []] | Output: [null, true, true, true, 2]",
                        "test3": "Input: [\"RandomizedSet\", \"insert\", \"insert\", \"insert\", \"getRandom\"]\n[[], [3], [3], [3], []] | Output: [null, true, false, false, 3]"
                },
                "codeSnippets": {
                        "java": "class RandomizedSet {\n    public RandomizedSet() {\n        // Write your code here\n    }\n    public boolean insert(int val) {\n        // Write your code here\n    }\n    public boolean remove(int val) {\n        // Write your code here\n    }\n    public int getRandom() {\n        // Write your code here\n    }\n}",
                        "python": "class RandomizedSet:\n    def __init__(self):\n        # Write your code here\n        pass\n    def insert(self, val: int) -> bool:\n        # Write your code here\n        pass\n    def remove(self, val: int) -> bool:\n        # Write your code here\n        pass\n    def getRandom(self) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass RandomizedSet {\npublic:\n    RandomizedSet() {\n        // Write your code here\n    }\n    bool insert(int val) {\n        // Write your code here\n    }\n    bool remove(int val) {\n        // Write your code here\n    }\n    int getRandom() {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Check if a String Contains all Binary Codes of Size K",
                "description": "Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false.",
                "topic": "Bit Manipulation",
                "subtopic": "Hashing",
                "level": "Medium",
                "tags": ["bit manipulation", "hashing", "sliding window"],
                "examples": {
                        "example1": "Input: s = '00110110', k = 2\nOutput: true",
                        "example2": "Input: s = '0110', k = 1\nOutput: true"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 10^5",
                        "constraint2": "s[i] is '0' or '1'",
                        "constraint3": "1 <= k <= 20"
                },
                "hints": {
                        "hint1": "Use a set to store unique substrings of length k.",
                        "hint2": "There are 2^k possible binary codes."
                },
                "testCases": {
                        "test1": "Input: '00110110', 2 | Output: true",
                        "test2": "Input: '0110', 1 | Output: true",
                        "test3": "Input: '0110', 2 | Output: false"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean hasAllCodes(String s, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def hasAllCodes(self, s: str, k: int) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool hasAllCodes(string s, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Non-Decreasing Array",
                "description": "Given an array nums with n integers, determine if the array can be made non-decreasing by modifying at most one element.",
                "topic": "Array",
                "subtopic": "Greedy",
                "level": "Medium",
                "tags": ["array", "greedy"],
                "examples": {
                        "example1": "Input: nums = [4,2,3]\nOutput: true",
                        "example2": "Input: nums = [4,2,1]\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^4",
                        "constraint2": "-10^5 <= nums[i] <= 10^5"
                },
                "hints": {
                        "hint1": "Consider modifying nums[i] or nums[i-1] when a violation is found.",
                        "hint2": "Make sure to keep track of the count of modifications."
                },
                "testCases": {
                        "test1": "Input: [4,2,3] | Output: true",
                        "test2": "Input: [4,2,1] | Output: false",
                        "test3": "Input: [3,4,2,3] | Output: false"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean checkPossibility(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def checkPossibility(self, nums: List[int]) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool checkPossibility(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Sign of an Array",
                "description": "Given an integer array nums, return the sign of the product of all elements. If the product is positive, return 1. If negative, return -1. If zero, return 0.",
                "topic": "Mathematics",
                "subtopic": "Sign Calculation",
                "level": "Easy",
                "tags": ["math", "array", "sign function"],
                "examples": {
                        "example1": "Input: nums = [-1,-2,-3,-4,3,2,1]\nOutput: 1",
                        "example2": "Input: nums = [1,5,0,2,-3]\nOutput: 0"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 1000",
                        "constraint2": "-100 <= nums[i] <= 100"
                },
                "hints": {
                        "hint1": "You don't need to calculate the actual product.",
                        "hint2": "Count the number of negative numbers."
                },
                "testCases": {
                        "test1": "Input: [-1,-2,-3,-4,3,2,1] | Output: 1",
                        "test2": "Input: [1,5,0,2,-3] | Output: 0",
                        "test3": "Input: [-1,2,3,-4] | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int arraySign(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def arraySign(self, nums: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int arraySign(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Union of Two Array",
                "description": "Given two arrays, return the union of the two arrays as a new array with distinct elements.",
                "topic": "Set",
                "subtopic": "Array Manipulation",
                "level": "Easy",
                "tags": ["array", "hash set", "sorting"],
                "examples": {
                        "example1": "Input: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [1,2]",
                        "example2": "Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [4,9,5,8]"
                },
                "constraints": {
                        "constraint1": "1 <= nums1.length, nums2.length <= 10^5",
                        "constraint2": "0 <= nums1[i], nums2[i] <= 10^9"
                },
                "hints": {
                        "hint1": "Use a set to store unique elements.",
                        "hint2": "Consider sorting the arrays before merging."
                },
                "testCases": {
                        "test1": "Input: [1,2,2,1], [2,2] | Output: [1,2]",
                        "test2": "Input: [4,9,5], [9,4,9,8,4] | Output: [4,9,5,8]",
                        "test3": "Input: [1,2,3], [4,5,6] | Output: [1,2,3,4,5,6]"
                },
                "codeSnippets": {
                        "java": "import java.util.*;\n\nclass Solution {\n    public int[] unionArray(int[] nums1, int[] nums2) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def unionArray(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <set>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> unionArray(vector<int>& nums1, vector<int>& nums2) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Merge Two Sorted Array",
                "description": "Given two sorted arrays, merge them into a single sorted array.",
                "topic": "Sorting",
                "subtopic": "Two Pointers",
                "level": "Easy",
                "tags": ["array", "merge", "sorting", "two pointers"],
                "examples": {
                        "example1": "Input: nums1 = [1,3,5], nums2 = [2,4,6]\nOutput: [1,2,3,4,5,6]",
                        "example2": "Input: nums1 = [0,2,4], nums2 = [1,3,5]\nOutput: [0,1,2,3,4,5]"
                },
                "constraints": {
                        "constraint1": "1 <= nums1.length, nums2.length <= 10^5",
                        "constraint2": "-10^9 <= nums1[i], nums2[i] <= 10^9"
                },
                "hints": {
                        "hint1": "Use a two-pointer approach.",
                        "hint2": "Merge both arrays while maintaining sorted order."
                },
                "testCases": {
                        "test1": "Input: [1,3,5], [2,4,6] | Output: [1,2,3,4,5,6]",
                        "test2": "Input: [0,2,4], [1,3,5] | Output: [0,1,2,3,4,5]",
                        "test3": "Input: [1,2,3], [] | Output: [1,2,3]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] mergeSortedArray(int[] nums1, int[] nums2) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def mergeSortedArray(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> mergeSortedArray(vector<int>& nums1, vector<int>& nums2) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Reverse String",
                "description": "Given a string, reverse it in place and return the modified string.",
                "topic": "String",
                "subtopic": "Two Pointers",
                "level": "Easy",
                "tags": ["string", "two pointers"],
                "examples": {
                        "example1": "Input: s = 'hello'\nOutput: 'olleh'",
                        "example2": "Input: s = 'racecar'\nOutput: 'racecar'"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 10^5",
                        "constraint2": "s consists of printable ASCII characters."
                },
                "hints": {
                        "hint1": "Use two pointers to swap characters from both ends.",
                        "hint2": "Iterate until the two pointers meet."
                },
                "testCases": {
                        "test1": "Input: 'hello' | Output: 'olleh'",
                        "test2": "Input: 'racecar' | Output: 'racecar'",
                        "test3": "Input: 'a' | Output: 'a'"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String reverseString(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def reverseString(self, s: str) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string reverseString(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Valid Palindrome",
                "description": "Given a string, determine if it is a palindrome by considering only alphanumeric characters and ignoring cases.",
                "topic": "String",
                "subtopic": "Two Pointers",
                "level": "Easy",
                "tags": ["string", "two pointers"],
                "examples": {
                        "example1": "Input: s = 'A man, a plan, a canal: Panama'\nOutput: true",
                        "example2": "Input: s = 'race a car'\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 10^5",
                        "constraint2": "s consists of printable ASCII characters."
                },
                "hints": {
                        "hint1": "Ignore non-alphanumeric characters.",
                        "hint2": "Use two pointers to check for palindrome property."
                },
                "testCases": {
                        "test1": "Input: 'A man, a plan, a canal: Panama' | Output: true",
                        "test2": "Input: 'race a car' | Output: false",
                        "test3": "Input: ' ' | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isPalindrome(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Valid Palindrome II",
                "description": "Given a string, return true if it can be a palindrome after deleting at most one character.",
                "topic": "String",
                "subtopic": "Two Pointers",
                "level": "Easy",
                "tags": ["string", "two pointers"],
                "examples": {
                        "example1": "Input: s = 'aba'\nOutput: true",
                        "example2": "Input: s = 'abca'\nOutput: true"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 10^5",
                        "constraint2": "s consists of lowercase English letters."
                },
                "hints": {
                        "hint1": "Use two pointers to check for palindrome property.",
                        "hint2": "If a mismatch is found, check both possible deletions."
                },
                "testCases": {
                        "test1": "Input: 'aba' | Output: true",
                        "test2": "Input: 'abca' | Output: true",
                        "test3": "Input: 'abc' | Output: false"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean validPalindrome(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def validPalindrome(self, s: str) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool validPalindrome(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Merge Strings Alternately",
                "description": "Given two strings, merge them by alternating characters from each string. If one string is longer, append the remaining characters at the end.",
                "topic": "String",
                "subtopic": "Two Pointers",
                "level": "Easy",
                "tags": ["string", "two pointers"],
                "examples": {
                        "example1": "Input: word1 = 'abc', word2 = 'pqr'\nOutput: 'apbqcr'",
                        "example2": "Input: word1 = 'ab', word2 = 'pqrs'\nOutput: 'apbqrs'"
                },
                "constraints": {
                        "constraint1": "1 <= word1.length, word2.length <= 100",
                        "constraint2": "word1 and word2 consist of lowercase English letters."
                },
                "hints": {
                        "hint1": "Use two pointers to iterate through both strings.",
                        "hint2": "Append remaining characters if one string is longer."
                },
                "testCases": {
                        "test1": "Input: 'abc', 'pqr' | Output: 'apbqcr'",
                        "test2": "Input: 'ab', 'pqrs' | Output: 'apbqrs'",
                        "test3": "Input: 'abcd', 'pq' | Output: 'apbqcd'"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String mergeAlternately(String word1, String word2) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string mergeAlternately(string word1, string word2) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Two Sum II - Input Array Is Sorted",
                "description": "Given a 1-indexed array of integers that is sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Return the indices of the two numbers.",
                "topic": "Array",
                "subtopic": "Two Pointers",
                "level": "Medium",
                "tags": ["array", "two pointers", "binary search"],
                "examples": {
                        "example1": "Input: numbers = [2,7,11,15], target = 9\nOutput: [1,2]",
                        "example2": "Input: numbers = [2,3,4], target = 6\nOutput: [1,3]"
                },
                "constraints": {
                        "constraint1": "2 <= numbers.length <= 3 * 10^4",
                        "constraint2": "-1000 <= numbers[i] <= 1000"
                },
                "hints": {
                        "hint1": "Use two pointers to find the pair efficiently.",
                        "hint2": "Since the array is sorted, you can move pointers based on the sum."
                },
                "testCases": {
                        "test1": "Input: [2,7,11,15], target = 9 | Output: [1,2]",
                        "test2": "Input: [2,3,4], target = 6 | Output: [1,3]",
                        "test3": "Input: [-1,0], target = -1 | Output: [1,2]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "3Sum",
                "description": "Given an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
                "topic": "Array",
                "subtopic": "Two Pointers",
                "level": "Medium",
                "tags": ["array", "two pointers", "sorting"],
                "examples": {
                        "example1": "Input: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]",
                        "example2": "Input: nums = []\nOutput: []"
                },
                "constraints": {
                        "constraint1": "0 <= nums.length <= 3000",
                        "constraint2": "-10^5 <= nums[i] <= 10^5"
                },
                "hints": {
                        "hint1": "Sort the array and use two pointers.",
                        "hint2": "Avoid duplicate triplets by skipping duplicates in the sorted array."
                },
                "testCases": {
                        "test1": "Input: [-1,0,1,2,-1,-4] | Output: [[-1,-1,2],[-1,0,1]]",
                        "test2": "Input: [] | Output: []",
                        "test3": "Input: [0,0,0] | Output: [[0,0,0]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "4Sum",
                "description": "Given an array nums of n integers, return all unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that a, b, c, and d are distinct and nums[a] + nums[b] + nums[c] + nums[d] == target.",
                "topic": "Array",
                "subtopic": "Two Pointers",
                "level": "Medium",
                "tags": ["array", "two pointers", "sorting"],
                "examples": {
                        "example1": "Input: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
                        "example2": "Input: nums = [], target = 0\nOutput: []"
                },
                "constraints": {
                        "constraint1": "0 <= nums.length <= 200",
                        "constraint2": "-10^9 <= nums[i] <= 10^9"
                },
                "hints": {
                        "hint1": "Sort the array and use two pointers.",
                        "hint2": "Avoid duplicate quadruplets by skipping duplicates in the sorted array."
                },
                "testCases": {
                        "test1": "Input: [1,0,-1,0,-2,2], target = 0 | Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
                        "test2": "Input: [], target = 0 | Output: []",
                        "test3": "Input: [0,0,0,0], target = 0 | Output: [[0,0,0,0]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Rotate Array",
                "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
                "topic": "Array Manipulation",
                "subtopic": "Rotation",
                "level": "Medium",
                "tags": ["array", "two pointers", "math"],
                "examples": {
                        "example1": "Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]",
                        "example2": "Input: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^5",
                        "constraint2": "-2^31 <= nums[i] <= 2^31 - 1",
                        "constraint3": "0 <= k <= 10^5"
                },
                "hints": {
                        "hint1": "Try using extra space to store the rotated elements.",
                        "hint2": "Can you do it in O(1) extra space?"
                },
                "testCases": {
                        "test1": "Input: [1,2,3,4,5,6,7], k = 3 | Output: [5,6,7,1,2,3,4]",
                        "test2": "Input: [-1,-100,3,99], k = 2 | Output: [3,99,-1,-100]",
                        "test3": "Input: [1], k = 0 | Output: [1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void rotate(int[] nums, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Container With Most Water",
                "description": "Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai), n vertical lines are drawn. Find two lines that together with the x-axis form a container that holds the most water.",
                "topic": "Greedy",
                "subtopic": "Two Pointers",
                "level": "Medium",
                "tags": ["array", "two pointers", "greedy"],
                "examples": {
                        "example1": "Input: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49",
                        "example2": "Input: height = [1,1]\nOutput: 1"
                },
                "constraints": {
                        "constraint1": "2 <= height.length <= 10^5",
                        "constraint2": "0 <= height[i] <= 10^4"
                },
                "hints": {
                        "hint1": "Use two pointers approach to optimize the solution.",
                        "hint2": "Move the pointer pointing to the shorter height."
                },
                "testCases": {
                        "test1": "Input: [1,8,6,2,5,4,8,3,7] | Output: 49",
                        "test2": "Input: [1,1] | Output: 1",
                        "test3": "Input: [4,3,2,1,4] | Output: 16"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int maxArea(int[] height) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Boats to Save People",
                "description": "Given an array people where people[i] is the weight of the i-th person, and an integer limit, each boat can carry at most two people at the same time provided the sum of their weights is at most limit. Return the minimum number of boats required to carry every given person.",
                "topic": "Greedy",
                "subtopic": "Two Pointers",
                "level": "Medium",
                "tags": ["array", "greedy", "two pointers"],
                "examples": {
                        "example1": "Input: people = [1,2], limit = 3\nOutput: 1",
                        "example2": "Input: people = [3,2,2,1], limit = 3\nOutput: 3"
                },
                "constraints": {
                        "constraint1": "1 <= people.length <= 5 * 10^4",
                        "constraint2": "1 <= people[i] <= limit <= 3 * 10^4"
                },
                "hints": {
                        "hint1": "Sort the array and use two pointers.",
                        "hint2": "Pair the lightest and heaviest person whenever possible."
                },
                "testCases": {
                        "test1": "Input: [1,2], limit = 3 | Output: 1",
                        "test2": "Input: [3,2,2,1], limit = 3 | Output: 3",
                        "test3": "Input: [3,5,3,4], limit = 5 | Output: 4"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int numRescueBoats(int[] people, int limit) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Trapping Rain Water",
                "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
                "topic": "Dynamic Programming",
                "subtopic": "Two Pointers",
                "level": "Hard",
                "tags": ["array", "two pointers", "dynamic programming", "stack"],
                "examples": {
                        "example1": "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6",
                        "example2": "Input: height = [4,2,0,3,2,5]\nOutput: 9"
                },
                "constraints": {
                        "constraint1": "1 <= height.length <= 10^5",
                        "constraint2": "0 <= height[i] <= 10^4"
                },
                "hints": {
                        "hint1": "Use two pointers to keep track of left and right boundaries.",
                        "hint2": "Keep track of the maximum heights on both sides."
                },
                "testCases": {
                        "test1": "Input: [0,1,0,2,1,0,1,3,2,1,2,1] | Output: 6",
                        "test2": "Input: [4,2,0,3,2,5] | Output: 9",
                        "test3": "Input: [2,0,2] | Output: 2"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int trap(int[] height) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Permutation In String",
                "description": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.",
                "topic": "Sliding Window",
                "subtopic": "String Manipulation",
                "level": "Medium",
                "tags": ["sliding window", "hash table", "two pointers"],
                "examples": {
                        "example1": "Input: s1 = 'ab', s2 = 'eidbaooo'\nOutput: true",
                        "example2": "Input: s1 = 'ab', s2 = 'eidboaoo'\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= s1.length, s2.length <= 10^4",
                        "constraint2": "s1 and s2 consist of lowercase English letters."
                },
                "hints": {
                        "hint1": "Use a sliding window to keep track of character counts.",
                        "hint2": "Check if the frequency of characters in the window matches s1."
                },
                "testCases": {
                        "test1": "Input: s1 = 'ab', s2 = 'eidbaooo' | Output: true",
                        "test2": "Input: s1 = 'ab', s2 = 'eidboaoo' | Output: false",
                        "test3": "Input: s1 = 'adc', s2 = 'dcda' | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool checkInclusion(string s1, string s2) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Minimum Size Subarray Sum",
                "description": "Given an array of positive integers nums and an integer target, return the minimal length of a contiguous subarray of which the sum is at least target. If no such subarray exists, return 0 instead.",
                "topic": "Sliding Window",
                "subtopic": "Two Pointers",
                "level": "Medium",
                "tags": ["array", "sliding window", "prefix sum"],
                "examples": {
                        "example1": "Input: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2",
                        "example2": "Input: target = 4, nums = [1,4,4]\nOutput: 1"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^5",
                        "constraint2": "1 <= nums[i] <= 10^4",
                        "constraint3": "1 <= target <= 10^9"
                },
                "hints": {
                        "hint1": "Use two pointers to maintain a sliding window.",
                        "hint2": "Expand the window when the sum is less than the target and contract it when the sum meets or exceeds the target."
                },
                "testCases": {
                        "test1": "Input: target = 7, nums = [2,3,1,2,4,3] | Output: 2",
                        "test2": "Input: target = 4, nums = [1,4,4] | Output: 1",
                        "test3": "Input: target = 11, nums = [1,1,1,1,1,1,1,1] | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Find K Closest Elements",
                "description": "Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should be sorted in ascending order.",
                "topic": "Binary Search",
                "subtopic": "Two Pointers",
                "level": "Medium",
                "tags": ["binary search", "two pointers", "heap"],
                "examples": {
                        "example1": "Input: arr = [1,2,3,4,5], k = 4, x = 3\nOutput: [1,2,3,4]",
                        "example2": "Input: arr = [1,2,3,4,5], k = 4, x = -1\nOutput: [1,2,3,4]"
                },
                "constraints": {
                        "constraint1": "1 <= k <= arr.length <= 10^4",
                        "constraint2": "-10^4 <= arr[i], x <= 10^4"
                },
                "hints": {
                        "hint1": "Use binary search to find the closest element to x.",
                        "hint2": "Use a two-pointer approach to expand and find the k closest elements."
                },
                "testCases": {
                        "test1": "Input: arr = [1,2,3,4,5], k = 4, x = 3 | Output: [1,2,3,4]",
                        "test2": "Input: arr = [1,2,3,4,5], k = 4, x = -1 | Output: [1,2,3,4]",
                        "test3": "Input: arr = [1,1,1,10,10,10], k = 1, x = 9 | Output: [10]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Minimum Window Substring",
                "description": "Given two strings s and t, return the minimum window substring of s such that every character in t appears at least once in the window. If no such substring exists, return an empty string.",
                "topic": "Sliding Window",
                "subtopic": "Two Pointers",
                "level": "Hard",
                "tags": ["sliding window", "hash table", "string"],
                "examples": {
                        "example1": "Input: s = 'ADOBECODEBANC', t = 'ABC'\nOutput: 'BANC'",
                        "example2": "Input: s = 'a', t = 'a'\nOutput: 'a'"
                },
                "constraints": {
                        "constraint1": "1 <= s.length, t.length <= 10^5",
                        "constraint2": "s and t consist of uppercase and lowercase English letters."
                },
                "hints": {
                        "hint1": "Use two pointers to maintain a sliding window.",
                        "hint2": "Expand the window to include characters in t and contract it when all characters are included."
                },
                "testCases": {
                        "test1": "Input: s = 'ADOBECODEBANC', t = 'ABC' | Output: 'BANC'",
                        "test2": "Input: s = 'a', t = 'a' | Output: 'a'",
                        "test3": "Input: s = 'a', t = 'aa' | Output: ''"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String minWindow(String s, String t) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Sliding Window Maximum",
                "description": "Given an array of integers nums and an integer k, return the maximum value in each sliding window of size k.",
                "topic": "Sliding Window",
                "subtopic": "Deque",
                "level": "Hard",
                "tags": ["sliding window", "deque", "heap"],
                "examples": {
                        "example1": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]",
                        "example2": "Input: nums = [1], k = 1\nOutput: [1]"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^5",
                        "constraint2": "-10^4 <= nums[i] <= 10^4",
                        "constraint3": "1 <= k <= nums.length"
                },
                "hints": {
                        "hint1": "Use a deque to store indices of useful elements in the current window.",
                        "hint2": "Remove elements that are out of the current window."
                },
                "testCases": {
                        "test1": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 | Output: [3,3,5,5,6,7]",
                        "test2": "Input: nums = [1], k = 1 | Output: [1]",
                        "test3": "Input: nums = [9,11], k = 2 | Output: [11]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Sum of All Subsets XOR Total",
                "description": "Given an integer array nums, find the sum of XOR totals for every subset of nums. The XOR total of a subset is defined as the bitwise XOR of all its elements. Return the sum of all XOR totals for every subset of nums.",
                "topic": "Backtracking",
                "subtopic": "Bit Manipulation",
                "level": "Medium",
                "tags": ["bit manipulation", "backtracking", "recursion"],
                "examples": {
                        "example1": "Input: nums = [1,3]\nOutput: 6",
                        "example2": "Input: nums = [5,1,6]\nOutput: 28"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 12",
                        "constraint2": "1 <= nums[i] <= 20"
                },
                "hints": {
                        "hint1": "Use backtracking to generate all subsets.",
                        "hint2": "Calculate XOR totals for each subset and sum them."
                },
                "testCases": {
                        "test1": "Input: [1,3] | Output: 6",
                        "test2": "Input: [5,1,6] | Output: 28",
                        "test3": "Input: [0] | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int subsetXORSum(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def subsetXORSum(self, nums: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int subsetXORSum(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Subsets",
                "description": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution must not contain duplicate subsets.",
                "topic": "Backtracking",
                "subtopic": "Bit Manipulation",
                "level": "Medium",
                "tags": ["backtracking", "bit manipulation", "array"],
                "examples": {
                        "example1": "Input: nums = [1,2,3]\nOutput: [[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]",
                        "example2": "Input: nums = [0]\nOutput: [[],[0]]"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10",
                        "constraint2": "-10 <= nums[i] <= 10",
                        "constraint3": "All elements of nums are unique"
                },
                "hints": {
                        "hint1": "Use backtracking to generate all subsets.",
                        "hint2": "A bitmask approach can also be used to generate subsets."
                },
                "testCases": {
                        "test1": "Input: [1,2,3] | Output: [[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]",
                        "test2": "Input: [0] | Output: [[],[0]]",
                        "test3": "Input: [4,5] | Output: [[],[4],[5],[4,5]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Combination Sum",
                "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. The same number may be chosen an unlimited number of times.",
                "topic": "Backtracking",
                "subtopic": "Recursion",
                "level": "Medium",
                "tags": ["backtracking", "recursion", "array"],
                "examples": {
                        "example1": "Input: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]",
                        "example2": "Input: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]"
                },
                "constraints": {
                        "constraint1": "1 <= candidates.length <= 30",
                        "constraint2": "1 <= candidates[i] <= 200",
                        "constraint3": "All elements of candidates are distinct",
                        "constraint4": "1 <= target <= 500"
                },
                "hints": {
                        "hint1": "Use backtracking to explore all possible combinations.",
                        "hint2": "Consider including the same element multiple times before moving to the next."
                },
                "testCases": {
                        "test1": "Input: [2,3,6,7], 7 | Output: [[2,2,3],[7]]",
                        "test2": "Input: [2,3,5], 8 | Output: [[2,2,2,2],[2,3,3],[3,5]]",
                        "test3": "Input: [2], 1 | Output: []"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Combination Sum II",
                "description": "Given a collection of candidate numbers (candidates) and a target number (target), return a list of all unique combinations of candidates where the chosen numbers sum to target. Each number in candidates may only be used once in the combination.",
                "topic": "Backtracking",
                "subtopic": "Recursion",
                "level": "Medium",
                "tags": ["backtracking", "recursion", "sorting"],
                "examples": {
                        "example1": "Input: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: [[1,1,6],[1,2,5],[1,7],[2,6]]",
                        "example2": "Input: candidates = [2,5,2,1,2], target = 5\nOutput: [[1,2,2],[5]]"
                },
                "constraints": {
                        "constraint1": "1 <= candidates.length <= 100",
                        "constraint2": "1 <= candidates[i] <= 50",
                        "constraint3": "1 <= target <= 30"
                },
                "hints": {
                        "hint1": "Sort the array to handle duplicates efficiently.",
                        "hint2": "Use backtracking with an index to ensure each number is only used once."
                },
                "testCases": {
                        "test1": "Input: [10,1,2,7,6,1,5], 8 | Output: [[1,1,6],[1,2,5],[1,7],[2,6]]",
                        "test2": "Input: [2,5,2,1,2], 5 | Output: [[1,2,2],[5]]",
                        "test3": "Input: [3,3,3,3], 6 | Output: [[3,3]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Combinations",
                "description": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].",
                "topic": "Backtracking",
                "subtopic": "Combinatorics",
                "level": "Medium",
                "tags": ["backtracking", "combinatorics"],
                "examples": {
                        "example1": "Input: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
                        "example2": "Input: n = 1, k = 1\nOutput: [[1]]"
                },
                "constraints": {
                        "constraint1": "1 <= k <= n <= 20"
                },
                "hints": {
                        "hint1": "Use backtracking to generate all possible combinations.",
                        "hint2": "You can start with an empty combination and recursively add elements."
                },
                "testCases": {
                        "test1": "Input: 4, 2 | Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
                        "test2": "Input: 1, 1 | Output: [[1]]",
                        "test3": "Input: 3, 3 | Output: [[1,2,3]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Permutations",
                "description": "Given an array nums of distinct integers, return all possible permutations in any order.",
                "topic": "Backtracking",
                "subtopic": "Recursion",
                "level": "Medium",
                "tags": ["backtracking", "recursion"],
                "examples": {
                        "example1": "Input: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
                        "example2": "Input: nums = [0,1]\nOutput: [[0,1],[1,0]]"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 6",
                        "constraint2": "-10 <= nums[i] <= 10",
                        "constraint3": "All elements of nums are unique"
                },
                "hints": {
                        "hint1": "Use backtracking to explore all possible orderings of the elements.",
                        "hint2": "Swap elements in the array to generate permutations efficiently."
                },
                "testCases": {
                        "test1": "Input: [1,2,3] | Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
                        "test2": "Input: [0,1] | Output: [[0,1],[1,0]]",
                        "test3": "Input: [1] | Output: [[1]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Subsets II",
                "description": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets.",
                "topic": "Backtracking",
                "subtopic": "Sorting and Pruning",
                "level": "Medium",
                "tags": ["backtracking", "sorting"],
                "examples": {
                        "example1": "Input: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]",
                        "example2": "Input: nums = [0]\nOutput: [[],[0]]"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10",
                        "constraint2": "-10 <= nums[i] <= 10"
                },
                "hints": {
                        "hint1": "Sort the input to handle duplicate elements efficiently.",
                        "hint2": "Use backtracking with a condition to skip duplicate elements."
                },
                "testCases": {
                        "test1": "Input: [1,2,2] | Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]",
                        "test2": "Input: [0] | Output: [[],[0]]",
                        "test3": "Input: [4,4,4,1,4] | Output: [[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Permutations II",
                "description": "Given a collection of numbers that might contain duplicates, return all possible unique permutations.",
                "topic": "Backtracking",
                "subtopic": "Sorting and Pruning",
                "level": "Medium",
                "tags": ["backtracking", "sorting"],
                "examples": {
                        "example1": "Input: nums = [1,1,2]\nOutput: [[1,1,2],[1,2,1],[2,1,1]]",
                        "example2": "Input: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 8",
                        "constraint2": "-10 <= nums[i] <= 10"
                },
                "hints": {
                        "hint1": "Sort the array to handle duplicate elements.",
                        "hint2": "Use a boolean array to track used elements and avoid duplicate permutations."
                },
                "testCases": {
                        "test1": "Input: [1,1,2] | Output: [[1,1,2],[1,2,1],[2,1,1]]",
                        "test2": "Input: [1,2,3] | Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
                        "test3": "Input: [2,2,1,1] | Output: [[1,1,2,2],[1,2,1,2],[1,2,2,1],[2,1,1,2],[2,1,2,1],[2,2,1,1]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Word Search",
                "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
                "topic": "Backtracking",
                "subtopic": "Graph Traversal",
                "level": "Medium",
                "tags": ["backtracking", "dfs", "matrix"],
                "examples": {
                        "example1": "Input: board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCCED'\nOutput: true",
                        "example2": "Input: board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'SEE'\nOutput: true"
                },
                "constraints": {
                        "constraint1": "1 <= board.length, board[i].length <= 6",
                        "constraint2": "1 <= word.length <= 15",
                        "constraint3": "board and word consist of only lowercase and uppercase English letters."
                },
                "hints": {
                        "hint1": "Try using Depth-First Search (DFS) with backtracking.",
                        "hint2": "Mark visited cells temporarily and revert back after the recursive call."
                },
                "testCases": {
                        "test1": "Input: [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'ABCCED' | Output: true",
                        "test2": "Input: [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'SEE' | Output: true",
                        "test3": "Input: [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'ABCB' | Output: false"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean exist(char[][] board, String word) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Palindrome Partitioning",
                "description": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.",
                "topic": "Backtracking",
                "subtopic": "String Manipulation",
                "level": "Medium",
                "tags": ["backtracking", "string"],
                "examples": {
                        "example1": "Input: s = 'aab'\nOutput: [['a','a','b'],['aa','b']]",
                        "example2": "Input: s = 'a'\nOutput: [['a']]"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 16",
                        "constraint2": "s consists of only lowercase English letters."
                },
                "hints": {
                        "hint1": "Use backtracking to explore all possible partitions.",
                        "hint2": "Check if a substring is a palindrome before adding it to the partition."
                },
                "testCases": {
                        "test1": "Input: 'aab' | Output: [['a','a','b'],['aa','b']]",
                        "test2": "Input: 'a' | Output: [['a']]",
                        "test3": "Input: 'abc' | Output: [['a','b','c']]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<String>> partition(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> partition(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Letter Combinations of a Phone Number",
                "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digit to letters (like on the telephone buttons) is given below.\n\n2 -> 'abc'\n3 -> 'def'\n4 -> 'ghi'\n5 -> 'jkl'\n6 -> 'mno'\n7 -> 'pqrs'\n8 -> 'tuv'\n9 -> 'wxyz'",
                "topic": "Backtracking",
                "subtopic": "String",
                "level": "Medium",
                "tags": ["backtracking", "string", "recursion"],
                "examples": {
                        "example1": "Input: digits = '23'\nOutput: ['ad','ae','af','bd','be','bf','cd','ce','cf']",
                        "example2": "Input: digits = ''\nOutput: []"
                },
                "constraints": {
                        "constraint1": "0 <= digits.length <= 4",
                        "constraint2": "digits[i] is a digit in ['2'-'9']."
                },
                "hints": {
                        "hint1": "Use recursion to explore all possible letter combinations.",
                        "hint2": "Maintain a mapping of digits to corresponding letters and iterate over choices."
                },
                "testCases": {
                        "test1": "Input: '23' | Output: ['ad','ae','af','bd','be','bf','cd','ce','cf']",
                        "test2": "Input: '' | Output: []",
                        "test3": "Input: '2' | Output: ['a','b','c']"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<String> letterCombinations(String digits) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Matchsticks to Square",
                "description": "You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, and each matchstick must be used exactly one time. Return true if you can make this square and false otherwise.",
                "topic": "Backtracking",
                "subtopic": "Recursion",
                "level": "Medium",
                "tags": ["backtracking", "bitmasking", "sorting"],
                "examples": {
                        "example1": "Input: matchsticks = [1,1,2,2,2]\nOutput: true",
                        "example2": "Input: matchsticks = [3,3,3,3,4]\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= matchsticks.length <= 15",
                        "constraint2": "1 <= matchsticks[i] <= 10^8"
                },
                "hints": {
                        "hint1": "Use backtracking to try different partitions.",
                        "hint2": "Sort matchsticks in descending order to optimize backtracking."
                },
                "testCases": {
                        "test1": "Input: [1,1,2,2,2] | Output: true",
                        "test2": "Input: [3,3,3,3,4] | Output: false",
                        "test3": "Input: [5,5,5,5,4,4,4,4,3,3,3,3] | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean makesquare(int[] matchsticks) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def makesquare(self, matchsticks: List[int]) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool makesquare(vector<int>& matchsticks) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Partition to K Equal Sum Subsets",
                "description": "Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.",
                "topic": "Backtracking",
                "subtopic": "Recursion",
                "level": "Medium",
                "tags": ["backtracking", "bitmasking", "recursion"],
                "examples": {
                        "example1": "Input: nums = [4,3,2,3,5,2,1], k = 4\nOutput: true",
                        "example2": "Input: nums = [1,2,3,4], k = 3\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= k <= nums.length <= 16",
                        "constraint2": "1 <= nums[i] <= 10^4"
                },
                "hints": {
                        "hint1": "Use backtracking to explore different ways of partitioning.",
                        "hint2": "Sort the numbers in descending order to optimize recursion."
                },
                "testCases": {
                        "test1": "Input: [4,3,2,3,5,2,1], k = 4 | Output: true",
                        "test2": "Input: [1,2,3,4], k = 3 | Output: false",
                        "test3": "Input: [10,10,10,7,7,7,7], k = 3 | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean canPartitionKSubsets(int[] nums, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "N Queens",
                "description": "The n-queens puzzle is the problem of placing n queens on an n × n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' indicate a queen and an empty space, respectively.",
                "topic": "Backtracking",
                "subtopic": "Recursion",
                "level": "Hard",
                "tags": ["backtracking", "recursion"],
                "examples": {
                        "example1": "Input: n = 4\nOutput: [['.Q..','...Q','Q...','..Q.'], ['..Q.','Q...','...Q','.Q..']]",
                        "example2": "Input: n = 1\nOutput: [['Q']]"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 9"
                },
                "hints": {
                        "hint1": "Use backtracking to explore valid placements of queens.",
                        "hint2": "Track occupied columns and diagonals to optimize recursion."
                },
                "testCases": {
                        "test1": "Input: 4 | Output: [['.Q..','...Q','Q...','..Q.'], ['..Q.','Q...','...Q','.Q..']]",
                        "test2": "Input: 1 | Output: [['Q']]",
                        "test3": "Input: 3 | Output: []"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "N Queens II",
                "description": "The n-queens puzzle is the problem of placing n queens on an n × n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle.",
                "topic": "Backtracking",
                "subtopic": "Recursion",
                "level": "Hard",
                "tags": ["backtracking", "recursion"],
                "examples": {
                        "example1": "Input: n = 4\nOutput: 2",
                        "example2": "Input: n = 1\nOutput: 1"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 9"
                },
                "hints": {
                        "hint1": "Use backtracking similar to the N Queens problem.",
                        "hint2": "Optimize by pruning columns and diagonals efficiently."
                },
                "testCases": {
                        "test1": "Input: 4 | Output: 2",
                        "test2": "Input: 1 | Output: 1",
                        "test3": "Input: 3 | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int totalNQueens(int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int totalNQueens(int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Word Break II",
                "description": "Given a string s and a dictionary of words dict, return all possible sentences by inserting spaces into s so that each segment is a valid word in dict. The same word in the dictionary can be reused multiple times.",
                "topic": "Backtracking",
                "subtopic": "Dynamic Programming",
                "level": "Hard",
                "tags": ["dynamic programming", "backtracking", "trie"],
                "examples": {
                        "example1": "Input: s = 'catsanddog', wordDict = ['cat', 'cats', 'and', 'sand', 'dog']\nOutput: ['cats and dog', 'cat sand dog']",
                        "example2": "Input: s = 'pineapplepenapple', wordDict = ['apple', 'pen', 'applepen', 'pine', 'pineapple']\nOutput: ['pine apple pen apple', 'pineapple pen apple', 'pine applepen apple']"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 20",
                        "constraint2": "1 <= wordDict.length <= 1000",
                        "constraint3": "1 <= wordDict[i].length <= 10",
                        "constraint4": "s and wordDict[i] consist of only lowercase English letters"
                },
                "hints": {
                        "hint1": "Use backtracking to explore different possible segmentations.",
                        "hint2": "Memoize intermediate results to optimize performance."
                },
                "testCases": {
                        "test1": "Input: 'catsanddog', ['cat', 'cats', 'and', 'sand', 'dog'] | Output: ['cats and dog', 'cat sand dog']",
                        "test2": "Input: 'pineapplepenapple', ['apple', 'pen', 'applepen', 'pine', 'pineapple'] | Output: ['pine apple pen apple', 'pineapple pen apple', 'pine applepen apple']",
                        "test3": "Input: 'catsandog', ['cats', 'dog', 'sand', 'and', 'cat'] | Output: []"
                },
                "codeSnippets": {
                        "java": "import java.util.*;\n\nclass Solution {\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Binary Search",
                "description": "Given a sorted array of integers and a target value, return the index if the target is found. Otherwise, return -1.",
                "topic": "Search",
                "subtopic": "Binary Search",
                "level": "Easy",
                "tags": ["binary search", "array"],
                "examples": {
                        "example1": "Input: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4",
                        "example2": "Input: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^4",
                        "constraint2": "-10^4 <= nums[i], target <= 10^4",
                        "constraint3": "nums is sorted in ascending order."
                },
                "hints": {
                        "hint1": "Use binary search to efficiently find the target.",
                        "hint2": "Maintain left and right pointers to narrow down the search space."
                },
                "testCases": {
                        "test1": "Input: nums = [-1,0,3,5,9,12], target = 9 | Output: 4",
                        "test2": "Input: nums = [-1,0,3,5,9,12], target = 2 | Output: -1",
                        "test3": "Input: nums = [5], target = 5 | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int search(int[] nums, int target) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Search Insert Position",
                "description": "Given a sorted array of distinct integers and a target value, return the index where the target should be inserted to maintain the sorted order.",
                "topic": "Search",
                "subtopic": "Binary Search",
                "level": "Easy",
                "tags": ["binary search", "array"],
                "examples": {
                        "example1": "Input: nums = [1,3,5,6], target = 5\nOutput: 2",
                        "example2": "Input: nums = [1,3,5,6], target = 2\nOutput: 1"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^4",
                        "constraint2": "-10^4 <= nums[i], target <= 10^4",
                        "constraint3": "nums contains distinct integers sorted in ascending order."
                },
                "hints": {
                        "hint1": "Use binary search to determine the correct insertion point.",
                        "hint2": "If the target is not found, return the index where it should be inserted."
                },
                "testCases": {
                        "test1": "Input: nums = [1,3,5,6], target = 5 | Output: 2",
                        "test2": "Input: nums = [1,3,5,6], target = 2 | Output: 1",
                        "test3": "Input: nums = [1,3,5,6], target = 7 | Output: 4"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Guess Number Higher or Lower",
                "description": "You have a number in mind between 1 and n. Your task is to implement a function that helps guess this number using the given API.",
                "topic": "Search",
                "subtopic": "Binary Search",
                "level": "Easy",
                "tags": ["binary search", "interactive"],
                "examples": {
                        "example1": "Input: n = 10, pick = 6\nOutput: 6",
                        "example2": "Input: n = 1, pick = 1\nOutput: 1"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 2^31 - 1",
                        "constraint2": "1 <= pick <= n"
                },
                "hints": {
                        "hint1": "Use binary search to efficiently guess the number.",
                        "hint2": "Compare your guess with the target using the API."
                },
                "testCases": {
                        "test1": "Input: n = 10, pick = 6 | Output: 6",
                        "test2": "Input: n = 1, pick = 1 | Output: 1",
                        "test3": "Input: n = 100, pick = 75 | Output: 75"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int guessNumber(int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def guessNumber(self, n: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int guessNumber(int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Sqrt(x)",
                "description": "Given a non-negative integer x, compute and return the square root of x rounded down to the nearest integer.",
                "topic": "Math",
                "subtopic": "Binary Search",
                "level": "Easy",
                "tags": ["math", "binary search"],
                "examples": {
                        "example1": "Input: x = 8\nOutput: 2",
                        "example2": "Input: x = 16\nOutput: 4"
                },
                "constraints": {
                        "constraint1": "0 <= x <= 2^31 - 1"
                },
                "hints": {
                        "hint1": "Try using binary search to find the square root.",
                        "hint2": "Check the mid-point squared value to determine whether to move left or right."
                },
                "testCases": {
                        "test1": "Input: x = 8 | Output: 2",
                        "test2": "Input: x = 16 | Output: 4",
                        "test3": "Input: x = 1 | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int mySqrt(int x) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Search a 2D Matrix",
                "description": "Given an m x n matrix where each row is sorted in ascending order and the first integer of each row is greater than the last integer of the previous row, write a function to search for a given target number.",
                "topic": "Search",
                "subtopic": "Binary Search",
                "level": "Medium",
                "tags": ["binary search", "matrix"],
                "examples": {
                        "example1": "Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true",
                        "example2": "Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false"
                },
                "constraints": {
                        "constraint1": "m == matrix.length",
                        "constraint2": "n == matrix[i].length",
                        "constraint3": "1 <= m, n <= 100",
                        "constraint4": "-10^4 <= matrix[i][j], target <= 10^4"
                },
                "hints": {
                        "hint1": "Flatten the 2D matrix into a 1D array and use binary search.",
                        "hint2": "Map the mid index of the flattened array to the corresponding row and column."
                },
                "testCases": {
                        "test1": "Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 | Output: true",
                        "test2": "Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 | Output: false",
                        "test3": "Input: matrix = [[1]], target = 1 | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Koko Eating Bananas",
                "description": "Koko loves to eat bananas. There are n piles of bananas, where the ith pile has piles[i] bananas. The guards come back in h hours. Koko can eat some bananas per hour, but can only eat from one pile at a time. Find the minimum eating speed so that Koko can finish all bananas within h hours.",
                "topic": "Search",
                "subtopic": "Binary Search",
                "level": "Medium",
                "tags": ["binary search", "greedy"],
                "examples": {
                        "example1": "Input: piles = [3,6,7,11], h = 8\nOutput: 4",
                        "example2": "Input: piles = [30,11,23,4,20], h = 5\nOutput: 30"
                },
                "constraints": {
                        "constraint1": "1 <= piles.length <= 10^4",
                        "constraint2": "1 <= piles[i] <= 10^9",
                        "constraint3": "piles.length <= h <= 10^9"
                },
                "hints": {
                        "hint1": "Use binary search on the eating speed.",
                        "hint2": "Check if a given speed allows Koko to finish eating within h hours."
                },
                "testCases": {
                        "test1": "Input: piles = [3,6,7,11], h = 8 | Output: 4",
                        "test2": "Input: piles = [30,11,23,4,20], h = 5 | Output: 30",
                        "test3": "Input: piles = [30,11,23,4,20], h = 6 | Output: 23"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int minEatingSpeed(int[] piles, int h) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Capacity to Ship Packages",
                "description": "A conveyor belt has packages that must be shipped from one port to another in `days` days. The `weights` array represents the weights of the packages, and you need to find the minimum capacity of the ship required to ship all packages within `days` days.",
                "topic": "Binary Search",
                "subtopic": "Greedy",
                "level": "Medium",
                "tags": ["binary search", "greedy", "array"],
                "examples": {
                        "example1": "Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5\nOutput: 15",
                        "example2": "Input: weights = [3,2,2,4,1,4], days = 3\nOutput: 6"
                },
                "constraints": {
                        "constraint1": "1 <= weights.length <= 5 * 10^4",
                        "constraint2": "1 <= weights[i] <= 500"
                },
                "hints": {
                        "hint1": "Use binary search to find the minimum ship capacity.",
                        "hint2": "Check if the given capacity allows shipment within the days limit."
                },
                "testCases": {
                        "test1": "Input: [1,2,3,4,5,6,7,8,9,10], days = 5 | Output: 15",
                        "test2": "Input: [3,2,2,4,1,4], days = 3 | Output: 6",
                        "test3": "Input: [1,2,3,1,1], days = 4 | Output: 3"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int shipWithinDays(int[] weights, int days) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def shipWithinDays(self, weights: List[int], days: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int shipWithinDays(vector<int>& weights, int days) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Find Minimum in Rotated Sorted Array",
                "description": "Given a rotated sorted array, find the minimum element.",
                "topic": "Binary Search",
                "subtopic": "Array",
                "level": "Medium",
                "tags": ["array", "binary search"],
                "examples": {
                        "example1": "Input: nums = [3,4,5,1,2]\nOutput: 1",
                        "example2": "Input: nums = [4,5,6,7,0,1,2]\nOutput: 0"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 5000",
                        "constraint2": "-5000 <= nums[i] <= 5000"
                },
                "hints": {
                        "hint1": "Use binary search to find the inflection point.",
                        "hint2": "Check the middle element and determine which half to search."
                },
                "testCases": {
                        "test1": "Input: [3,4,5,1,2] | Output: 1",
                        "test2": "Input: [4,5,6,7,0,1,2] | Output: 0",
                        "test3": "Input: [11,13,15,17] | Output: 11"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int findMin(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Search in Rotated Sorted Array",
                "description": "Given a rotated sorted array and a target value, search for the target and return its index. If it is not found, return -1.",
                "topic": "Binary Search",
                "subtopic": "Array",
                "level": "Medium",
                "tags": ["array", "binary search"],
                "examples": {
                        "example1": "Input: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4",
                        "example2": "Input: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 5000",
                        "constraint2": "-10^4 <= nums[i] <= 10^4"
                },
                "hints": {
                        "hint1": "Use binary search to locate the pivot point.",
                        "hint2": "Determine which half to search based on the pivot."
                },
                "testCases": {
                        "test1": "Input: [4,5,6,7,0,1,2], target = 0 | Output: 4",
                        "test2": "Input: [4,5,6,7,0,1,2], target = 3 | Output: -1",
                        "test3": "Input: [1], target = 0 | Output: -1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int search(int[] nums, int target) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Search In Rotated Sorted Array II",
                "description": "Given an integer array nums that may contain duplicates and is sorted in ascending order, but rotated at an unknown pivot, write a function to determine if a given target is in nums.",
                "topic": "Search",
                "subtopic": "Binary Search",
                "level": "Medium",
                "tags": ["binary search", "array"],
                "examples": {
                        "example1": "Input: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true",
                        "example2": "Input: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 5000",
                        "constraint2": "-10^4 <= nums[i], target <= 10^4"
                },
                "hints": {
                        "hint1": "Modify binary search to handle duplicates.",
                        "hint2": "Compare mid with the left and right ends to decide the search space."
                },
                "testCases": {
                        "test1": "Input: nums = [2,5,6,0,0,1,2], target = 0 | Output: true",
                        "test2": "Input: nums = [2,5,6,0,0,1,2], target = 3 | Output: false",
                        "test3": "Input: nums = [1,1,1,1,1,1,1,1], target = 1 | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean search(int[] nums, int target) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool search(vector<int>& nums, int target) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Time Based Key Value Store",
                "description": "Design a time-based key-value store that can store multiple values for the same key at different timestamps and retrieve the most recent value before a given timestamp.",
                "topic": "Data Structures",
                "subtopic": "Binary Search",
                "level": "Medium",
                "tags": ["binary search", "hash map"],
                "examples": {
                        "example1": "Input: ['TimeMap', 'set', 'get', 'get', 'set', 'get', 'get']\nArguments: [[], ['foo','bar',1], ['foo',1], ['foo',3], ['foo','bar2',4], ['foo',4], ['foo',5]]\nOutput: [null, null, 'bar', 'bar', null, 'bar2', 'bar2']",
                        "example2": "Input: ['TimeMap', 'set', 'get']\nArguments: [[], ['foo', 'bar', 10], ['foo', 5]]\nOutput: [null, null, '']"
                },
                "constraints": {
                        "constraint1": "1 <= key.length, value.length <= 100",
                        "constraint2": "0 <= timestamp <= 10^7",
                        "constraint3": "All timestamps for the same key are strictly increasing"
                },
                "hints": {
                        "hint1": "Use a hash map where each key maps to a list of (timestamp, value) pairs.",
                        "hint2": "Use binary search to quickly find the largest timestamp ≤ the query timestamp."
                },
                "testCases": {
                        "test1": "Input: ['TimeMap', 'set', 'get', 'get', 'set', 'get', 'get'] | Arguments: [[], ['foo','bar',1], ['foo',1], ['foo',3], ['foo','bar2',4], ['foo',4], ['foo',5]] | Output: [null, null, 'bar', 'bar', null, 'bar2', 'bar2']",
                        "test2": "Input: ['TimeMap', 'set', 'get'] | Arguments: [[], ['foo', 'bar', 10], ['foo', 5]] | Output: [null, null, '']"
                },
                "codeSnippets": {
                        "java": "class TimeMap {\n    public TimeMap() {\n        // Constructor\n    }\n    public void set(String key, String value, int timestamp) {\n        // Write your code here\n    }\n    public String get(String key, int timestamp) {\n        // Write your code here\n    }\n}",
                        "python": "class TimeMap:\n    def __init__(self):\n        # Constructor\n        pass\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # Write your code here\n        pass\n    def get(self, key: str, timestamp: int) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass TimeMap {\npublic:\n    TimeMap() {\n        // Constructor\n    }\n    void set(string key, string value, int timestamp) {\n        // Write your code here\n    }\n    string get(string key, int timestamp) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Split Array Largest Sum",
                "description": "Given an array nums and an integer m, partition the array into m non-empty subarrays such that the largest sum among these subarrays is minimized. Return the minimized largest sum.",
                "topic": "Search",
                "subtopic": "Binary Search",
                "level": "Hard",
                "tags": ["binary search", "dynamic programming"],
                "examples": {
                        "example1": "Input: nums = [7,2,5,10,8], m = 2\nOutput: 18",
                        "example2": "Input: nums = [1,2,3,4,5], m = 2\nOutput: 9"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 1000",
                        "constraint2": "0 <= nums[i] <= 10^6",
                        "constraint3": "1 <= m <= min(50, nums.length)"
                },
                "hints": {
                        "hint1": "Use binary search on the possible largest sum.",
                        "hint2": "Use a greedy algorithm to determine if a given sum is possible."
                },
                "testCases": {
                        "test1": "Input: nums = [7,2,5,10,8], m = 2 | Output: 18",
                        "test2": "Input: nums = [1,2,3,4,5], m = 2 | Output: 9",
                        "test3": "Input: nums = [1,4,4], m = 3 | Output: 4"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int splitArray(int[] nums, int m) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def splitArray(self, nums: List[int], m: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int splitArray(vector<int>& nums, int m) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Median of Two Sorted Array",
                "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
                "topic": "Search",
                "subtopic": "Binary Search",
                "level": "Hard",
                "tags": ["binary search", "array", "divide and conquer"],
                "examples": {
                        "example1": "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000",
                        "example2": "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000"
                },
                "constraints": {
                        "constraint1": "0 <= nums1.length, nums2.length <= 1000",
                        "constraint2": "-10^6 <= nums1[i], nums2[i] <= 10^6",
                        "constraint3": "nums1 and nums2 are sorted in non-decreasing order."
                },
                "hints": {
                        "hint1": "Use binary search on the smaller array.",
                        "hint2": "Think about how to partition the arrays to get the median."
                },
                "testCases": {
                        "test1": "Input: nums1 = [1,3], nums2 = [2] | Output: 2.00000",
                        "test2": "Input: nums1 = [1,2], nums2 = [3,4] | Output: 2.50000",
                        "test3": "Input: nums1 = [0,0], nums2 = [0,0] | Output: 0.00000"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public double findMedianSortedArray(int[] nums1, int[] nums2) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findMedianSortedArray(self, nums1: List[int], nums2: List[int]) -> float:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    double findMedianSortedArray(vector<int>& nums1, vector<int>& nums2) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Find in Mountain Array",
                "description": "Given a mountain array mountainArr and a target integer target, return the index of target in mountainArr. If target does not exist, return -1. You must solve it in less than O(n) time complexity.",
                "topic": "Search",
                "subtopic": "Binary Search",
                "level": "Hard",
                "tags": ["binary search", "array"],
                "examples": {
                        "example1": "Input: mountainArr = [1,2,3,4,5,3,1], target = 3\nOutput: 2",
                        "example2": "Input: mountainArr = [0,1,2,4,2,1], target = 3\nOutput: -1"
                },
                "constraints": {
                        "constraint1": "3 <= mountainArr.length <= 10^4",
                        "constraint2": "0 <= mountainArr[i] <= 10^9",
                        "constraint3": "There exists an index i such that 0 < i < mountainArr.length - 1 and mountainArr[i-1] < mountainArr[i] > mountainArr[i+1]"
                },
                "hints": {
                        "hint1": "Find the peak element first.",
                        "hint2": "Perform binary search on both halves of the array."
                },
                "testCases": {
                        "test1": "Input: mountainArr = [1,2,3,4,5,3,1], target = 3 | Output: 2",
                        "test2": "Input: mountainArr = [0,1,2,4,2,1], target = 3 | Output: -1",
                        "test3": "Input: mountainArr = [0,5,3,1], target = 1 | Output: 3"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int findInMountainArray(int target, MountainArray mountainArr) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findInMountainArray(self, target: int, mountainArr: 'MountainArray') -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findInMountainArray(int target, MountainArray &mountainArr) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Island Perimeter",
                "description": "You are given a grid representing a map where 1 represents land and 0 represents water. The grid is completely surrounded by water, and each land cell is connected horizontally or vertically (not diagonally). Find the perimeter of the island in the grid.",
                "topic": "Graph",
                "subtopic": "DFS / BFS",
                "level": "Easy",
                "tags": ["graph", "dfs", "bfs", "matrix"],
                "examples": {
                        "example1": "Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\nOutput: 16"
                },
                "constraints": {
                        "constraint1": "1 <= grid.length, grid[0].length <= 100",
                        "constraint2": "grid[i][j] is 0 or 1"
                },
                "hints": {
                        "hint1": "Count edges that contribute to the perimeter.",
                        "hint2": "Iterate over the grid and check neighboring cells."
                },
                "testCases": {
                        "test1": "Input: [[1]] | Output: 4",
                        "test2": "Input: [[1,0]] | Output: 4",
                        "test3": "Input: [[1,1],[1,1]] | Output: 8"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int islandPerimeter(int[][] grid) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int islandPerimeter(vector<vector<int>>& grid) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Verifying An Alien Dictionary",
                "description": "In an alien language, the order of the letters is unknown. Given a sequence of words written in this alien language and a string representing the order of the alphabet, return true if the words are sorted lexicographically in this order.",
                "topic": "Strings",
                "subtopic": "Sorting",
                "level": "Easy",
                "tags": ["string", "sorting", "hash table"],
                "examples": {
                        "example1": "Input: words = ['hello','leetcode'], order = 'hlabcdefgijkmnopqrstuvwxyz'\nOutput: true",
                        "example2": "Input: words = ['word','world','row'], order = 'worldabcefghijkmnpqstuvxyz'\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= words.length <= 100",
                        "constraint2": "1 <= words[i].length <= 20",
                        "constraint3": "order.length == 26",
                        "constraint4": "All words and order contain only lowercase English letters"
                },
                "hints": {
                        "hint1": "Create a mapping of character orders.",
                        "hint2": "Compare adjacent words based on the alien order."
                },
                "testCases": {
                        "test1": "Input: ['apple','app'], 'abcdefghijklmnopqrstuvwxyz' | Output: false",
                        "test2": "Input: ['abc','ab'], 'abcdefghijklmnopqrstuvwxyz' | Output: false",
                        "test3": "Input: ['hello','leetcode'], 'hlabcdefgijkmnopqrstuvwxyz' | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isAlienSorted(String[] words, String order) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isAlienSorted(vector<string>& words, string order) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Find the Town Judge",
                "description": "In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is the town judge. If the town judge exists, they must be trusted by everyone except themselves and must trust no one. Given an array trust[], where trust[i] = [a, b] means person a trusts person b, find the judge or return -1 if no judge exists.",
                "topic": "Graph",
                "subtopic": "In-Degree / Out-Degree",
                "level": "Easy",
                "tags": ["graph", "hash table"],
                "examples": {
                        "example1": "Input: n = 2, trust = [[1,2]]\nOutput: 2",
                        "example2": "Input: n = 3, trust = [[1,3],[2,3]]\nOutput: 3",
                        "example3": "Input: n = 3, trust = [[1,3],[2,3],[3,1]]\nOutput: -1"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 1000",
                        "constraint2": "0 <= trust.length <= 10^4",
                        "constraint3": "trust[i].length == 2",
                        "constraint4": "1 <= trust[i][0], trust[i][1] <= n",
                        "constraint5": "trust[i][0] != trust[i][1]"
                },
                "hints": {
                        "hint1": "Use an array to track how many people each person trusts and how many trust them.",
                        "hint2": "A judge will have n-1 people trusting them and will trust nobody."
                },
                "testCases": {
                        "test1": "Input: 3, [[1,3],[2,3]] | Output: 3",
                        "test2": "Input: 3, [[1,3],[2,3],[3,1]] | Output: -1",
                        "test3": "Input: 1, [] | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int findJudge(int n, int[][] trust) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Number of Islands",
                "description": "Given an m x n grid where '1' represents land and '0' represents water, return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.",
                "topic": "Graph",
                "subtopic": "DFS / BFS",
                "level": "Medium",
                "tags": ["graph", "dfs", "bfs", "matrix"],
                "examples": {
                        "example1": "Input: grid = [['1','1','1','0','0'],['1','1','0','0','0'],['0','0','0','1','1'],['0','0','0','1','1']]\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "1 <= grid.length, grid[0].length <= 300",
                        "constraint2": "grid[i][j] is '0' or '1'"
                },
                "hints": {
                        "hint1": "Use DFS or BFS to traverse the grid.",
                        "hint2": "Mark visited land cells to avoid reprocessing."
                },
                "testCases": {
                        "test1": "Input: [['1','1','1','0','0'],['1','1','0','0','0'],['0','0','0','1','1'],['0','0','0','1','1']] | Output: 2",
                        "test2": "Input: [['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']] | Output: 3",
                        "test3": "Input: [['0','0','0'],['0','0','0']] | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int numIslands(char[][] grid) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Max Area of Island",
                "description": "Given an m x n binary grid where 1 represents land and 0 represents water, return the maximum area of an island in the grid. An island is a group of connected 1s and is surrounded by water. You may assume all four edges of the grid are surrounded by water.",
                "topic": "Graph",
                "subtopic": "DFS / BFS",
                "level": "Medium",
                "tags": ["graph", "dfs", "bfs", "matrix"],
                "examples": {
                        "example1": "Input: grid = [[0,0,1,0,0],[1,1,1,0,0],[0,1,0,0,0],[1,1,0,0,0]]\nOutput: 5"
                },
                "constraints": {
                        "constraint1": "1 <= grid.length, grid[0].length <= 50",
                        "constraint2": "grid[i][j] is 0 or 1"
                },
                "hints": {
                        "hint1": "Use DFS or BFS to find connected components.",
                        "hint2": "Track the maximum area encountered."
                },
                "testCases": {
                        "test1": "Input: [[0,0,1,0,0],[1,1,1,0,0],[0,1,0,0,0],[1,1,0,0,0]] | Output: 5",
                        "test2": "Input: [[0,0,0,0,0],[0,1,1,1,0],[0,1,1,1,0],[0,0,0,0,0]] | Output: 6",
                        "test3": "Input: [[0,0,0],[0,0,0]] | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Clone Graph",
                "description": "Given a reference to a node in a connected undirected graph, return a deep copy of the graph. Each node in the graph contains an integer value and a list of neighbors.",
                "topic": "Graph",
                "subtopic": "DFS / BFS",
                "level": "Medium",
                "tags": ["graph", "dfs", "bfs", "hash table"],
                "examples": {
                        "example1": "Input: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the graph is in the range [0, 100].",
                        "constraint2": "Node values are unique and in the range [1, 100]."
                },
                "hints": {
                        "hint1": "Use DFS or BFS to traverse the graph.",
                        "hint2": "Maintain a mapping of original nodes to cloned nodes."
                },
                "testCases": {
                        "test1": "Input: [[2,4],[1,3],[2,4],[1,3]] | Output: [[2,4],[1,3],[2,4],[1,3]]",
                        "test2": "Input: [[]] | Output: [[]]",
                        "test3": "Input: [[2],[1]] | Output: [[2],[1]]"
                },
                "codeSnippets": {
                        "java": "class Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        // Write your code here\n    }\n}",
                        "python": "class Node:\n    def __init__(self, val=0, neighbors=[]):\n        self.val = val\n        self.neighbors = neighbors\n\nclass Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val, vector<Node*> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n\nclass Solution {\npublic:\n    Node* cloneGraph(Node* node) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Walls And Gates",
                "description": "You are given an m x n grid filled with empty rooms, walls, and gates. Each empty room should be filled with the distance to its nearest gate. If it is impossible to reach a gate, the room should remain INF.",
                "topic": "Graph",
                "subtopic": "BFS",
                "level": "Medium",
                "tags": ["graph", "bfs", "matrix"],
                "examples": {
                        "example1": "Input: rooms = [[INF,-1,0,INF],[INF,INF,INF,-1],[INF,-1,INF,-1],[0,-1,INF,INF]]\nOutput: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]"
                },
                "constraints": {
                        "constraint1": "1 <= rooms.length, rooms[0].length <= 200",
                        "constraint2": "rooms[i][j] is -1 (wall), 0 (gate), or INF (empty room)"
                },
                "hints": {
                        "hint1": "Use BFS from all gates simultaneously.",
                        "hint2": "Update distances layer by layer."
                },
                "testCases": {
                        "test1": "Input: [[INF,-1,0,INF],[INF,INF,INF,-1],[INF,-1,INF,-1],[0,-1,INF,INF]] | Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]",
                        "test2": "Input: [[0,INF],[INF,INF]] | Output: [[0,1],[1,2]]",
                        "test3": "Input: [[-1]] | Output: [[-1]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void wallsAndGates(int[][] rooms) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def wallsAndGates(self, rooms: List[List[int]]) -> None:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    void wallsAndGates(vector<vector<int>>& rooms) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Rotting Oranges",
                "description": "Given an m x n grid where each cell can be an empty cell, a fresh orange, or a rotten orange, return the minimum number of minutes required for all oranges to become rotten. If it is impossible, return -1.",
                "topic": "Graph",
                "subtopic": "BFS",
                "level": "Medium",
                "tags": ["graph", "bfs", "matrix"],
                "examples": {
                        "example1": "Input: grid = [[2,1,1],[1,1,0],[0,1,1]]\nOutput: 4"
                },
                "constraints": {
                        "constraint1": "1 <= grid.length, grid[0].length <= 10",
                        "constraint2": "grid[i][j] is 0 (empty), 1 (fresh orange), or 2 (rotten orange)"
                },
                "hints": {
                        "hint1": "Use BFS to spread rotting effect.",
                        "hint2": "Track the time taken for all fresh oranges to rot."
                },
                "testCases": {
                        "test1": "Input: [[2,1,1],[1,1,0],[0,1,1]] | Output: 4",
                        "test2": "Input: [[2,1,1],[0,1,1],[1,0,1]] | Output: -1",
                        "test3": "Input: [[0,2]] | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int orangesRotting(int[][] grid) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int orangesRotting(vector<vector<int>>& grid) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Pacific Atlantic Water Flow",
                "description": "Given an m x n matrix of heights, return the list of grid coordinates where water can flow to both the Pacific and Atlantic oceans.",
                "topic": "Graph",
                "subtopic": "DFS / BFS",
                "level": "Medium",
                "tags": ["graph", "dfs", "bfs", "matrix"],
                "examples": {
                        "example1": "Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"
                },
                "constraints": {
                        "constraint1": "1 <= heights.length, heights[0].length <= 200",
                        "constraint2": "0 <= heights[i][j] <= 10^5"
                },
                "hints": {
                        "hint1": "Use DFS or BFS from the ocean edges.",
                        "hint2": "Track visited nodes for each ocean separately."
                },
                "testCases": {
                        "test1": "Input: [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]] | Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]",
                        "test2": "Input: [[2,1],[1,2]] | Output: [[0,0],[0,1],[1,0],[1,1]]",
                        "test3": "Input: [[1]] | Output: [[0,0]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Surrounded Regions",
                "description": "Given an m x n board filled with 'X' and 'O', capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's if it is completely surrounded by 'X' on all sides.",
                "topic": "Graph",
                "subtopic": "DFS / BFS",
                "level": "Medium",
                "tags": ["graph", "dfs", "bfs", "matrix"],
                "examples": {
                        "example1": "Input: board = [['X','X','X','X'],['X','O','O','X'],['X','X','O','X'],['X','O','X','X']]\nOutput: [['X','X','X','X'],['X','X','X','X'],['X','X','X','X'],['X','O','X','X']]"
                },
                "constraints": {
                        "constraint1": "1 <= board.length, board[0].length <= 200",
                        "constraint2": "board[i][j] is 'X' or 'O'"
                },
                "hints": {
                        "hint1": "Use DFS or BFS to mark 'O's connected to the boundary.",
                        "hint2": "Only flip 'O's that are not connected to the boundary."
                },
                "testCases": {
                        "test1": "Input: [['X','X','X','X'],['X','O','O','X'],['X','X','O','X'],['X','O','X','X']] | Output: [['X','X','X','X'],['X','X','X','X'],['X','X','X','X'],['X','O','X','X']]",
                        "test2": "Input: [['O','O'],['O','O']] | Output: [['O','O'],['O','O']]",
                        "test3": "Input: [['X']] | Output: [['X']]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void solve(char[][] board) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    void solve(vector<vector<char>>& board) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Open The Lock",
                "description": "You have a lock with four rotating wheels, each with digits 0-9. Given a list of deadends and a target combination, return the minimum number of moves to unlock the lock, or -1 if impossible.",
                "topic": "Graph",
                "subtopic": "BFS",
                "level": "Medium",
                "tags": ["graph", "bfs", "queue"],
                "examples": {
                        "example1": "Input: deadends = ['0201','0101','0102','1212','2002'], target = '0202'\nOutput: 6"
                },
                "constraints": {
                        "constraint1": "1 <= deadends.length <= 500",
                        "constraint2": "target.length == 4, contains only digits 0-9"
                },
                "hints": {
                        "hint1": "Use BFS to find the shortest path.",
                        "hint2": "Avoid revisiting deadends."
                },
                "testCases": {
                        "test1": "Input: deadends = ['0201','0101','0102','1212','2002'], target = '0202' | Output: 6",
                        "test2": "Input: deadends = ['8888'], target = '0009' | Output: 1",
                        "test3": "Input: deadends = ['0000'], target = '8888' | Output: -1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int openLock(String[] deadends, String target) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def openLock(self, deadends: List[str], target: str) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int openLock(vector<string>& deadends, string target) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Course Schedule",
                "description": "You are given n courses labeled from 0 to n-1 and a list of prerequisite pairs. Determine if it is possible to finish all courses.",
                "topic": "Graph",
                "subtopic": "Topological Sort",
                "level": "Medium",
                "tags": ["graph", "topological sort", "bfs", "dfs"],
                "examples": {
                        "example1": "Input: numCourses = 2, prerequisites = [[1,0]]\nOutput: true",
                        "example2": "Input: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= numCourses <= 2000",
                        "constraint2": "0 <= prerequisites.length <= 5000"
                },
                "hints": {
                        "hint1": "Model the problem as a directed graph.",
                        "hint2": "Use Topological Sorting (Kahn’s algorithm or DFS)."
                },
                "testCases": {
                        "test1": "Input: numCourses = 2, prerequisites = [[1,0]] | Output: true",
                        "test2": "Input: numCourses = 2, prerequisites = [[1,0],[0,1]] | Output: false",
                        "test3": "Input: numCourses = 3, prerequisites = [[1,0],[2,1]] | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Course Schedule II",
                "description": "You are given n courses labeled from 0 to n-1 and a list of prerequisite pairs. Return the ordering of courses you should take to finish all courses. If there are multiple valid orderings, return any of them. If it is impossible, return an empty array.",
                "topic": "Graph",
                "subtopic": "Topological Sort",
                "level": "Medium",
                "tags": ["graph", "topological sort", "bfs", "dfs"],
                "examples": {
                        "example1": "Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,1,2,3] or [0,2,1,3]"
                },
                "constraints": {
                        "constraint1": "1 <= numCourses <= 2000",
                        "constraint2": "0 <= prerequisites.length <= 5000"
                },
                "hints": {
                        "hint1": "Model the problem as a directed graph.",
                        "hint2": "Use Topological Sorting (Kahn’s algorithm or DFS)."
                },
                "testCases": {
                        "test1": "Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]] | Output: [0,1,2,3] or [0,2,1,3]",
                        "test2": "Input: numCourses = 2, prerequisites = [[1,0],[0,1]] | Output: []",
                        "test3": "Input: numCourses = 1, prerequisites = [] | Output: [0]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Graph Valid Tree",
                "description": "Given n nodes labeled from 0 to n-1 and a list of undirected edges, determine if the edges form a valid tree.",
                "topic": "Graph",
                "subtopic": "Union Find / DFS / BFS",
                "level": "Medium",
                "tags": ["graph", "union find", "dfs", "bfs"],
                "examples": {
                        "example1": "Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]\nOutput: true",
                        "example2": "Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 2000",
                        "constraint2": "0 <= edges.length <= 2000"
                },
                "hints": {
                        "hint1": "A valid tree has exactly n-1 edges and no cycles.",
                        "hint2": "Use Union-Find or DFS to detect cycles."
                },
                "testCases": {
                        "test1": "Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]] | Output: true",
                        "test2": "Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]] | Output: false",
                        "test3": "Input: n = 1, edges = [] | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean validTree(int n, int[][] edges) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def validTree(self, n: int, edges: List[List[int]]) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool validTree(int n, vector<vector<int>>& edges) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Course Schedule IV",
                "description": "You are given n courses labeled from 0 to n-1 and a list of prerequisite pairs. You are also given a list of queries where each query asks whether a specific course is a prerequisite of another course. Return a list of boolean values answering the queries.",
                "topic": "Graph",
                "subtopic": "Floyd-Warshall / DFS",
                "level": "Medium",
                "tags": ["graph", "floyd-warshall", "dfs"],
                "examples": {
                        "example1": "Input: numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]\nOutput: [false, true]"
                },
                "constraints": {
                        "constraint1": "2 <= numCourses <= 100",
                        "constraint2": "0 <= prerequisites.length <= (numCourses * (numCourses - 1)) / 2"
                },
                "hints": {
                        "hint1": "Use Floyd-Warshall to determine reachability.",
                        "hint2": "Alternatively, use DFS for each query."
                },
                "testCases": {
                        "test1": "Input: numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]] | Output: [false, true]",
                        "test2": "Input: numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[0,1]] | Output: [true, false]",
                        "test3": "Input: numCourses = 3, prerequisites = [], queries = [[1,2],[0,2]] | Output: [false, false]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Number of Connected Components In An Undirected Graph",
                "description": "You are given an integer n representing the number of nodes in an undirected graph and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph. Return the number of connected components in the graph.",
                "topic": "Graph",
                "subtopic": "Union-Find / DFS / BFS",
                "level": "Medium",
                "tags": ["graph", "union find", "dfs", "bfs"],
                "examples": {
                        "example1": "Input: n = 5, edges = [[0,1],[1,2],[3,4]]\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 2000",
                        "constraint2": "0 <= edges.length <= 2000"
                },
                "hints": {
                        "hint1": "Use Union-Find to track connected components.",
                        "hint2": "Alternatively, use DFS or BFS to traverse components."
                },
                "testCases": {
                        "test1": "Input: n = 5, edges = [[0,1],[1,2],[3,4]] | Output: 2",
                        "test2": "Input: n = 4, edges = [[0,1],[2,3]] | Output: 2",
                        "test3": "Input: n = 3, edges = [[0,1],[1,2],[2,0]] | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int countComponents(int n, int[][] edges) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int countComponents(int n, vector<vector<int>>& edges) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Redundant Connection",
                "description": "In a tree with n nodes labeled from 1 to n, there is exactly one edge that can be removed to make it a tree. Given an edge list of a graph, return the edge that can be removed while keeping the graph fully connected.",
                "topic": "Graph",
                "subtopic": "Union-Find",
                "level": "Medium",
                "tags": ["graph", "union find"],
                "examples": {
                        "example1": "Input: edges = [[1,2],[1,3],[2,3]]\nOutput: [2,3]"
                },
                "constraints": {
                        "constraint1": "3 <= n <= 1000",
                        "constraint2": "edges.length == n"
                },
                "hints": {
                        "hint1": "Use the Union-Find algorithm to detect cycles.",
                        "hint2": "Find the edge that creates a cycle and return it."
                },
                "testCases": {
                        "test1": "Input: edges = [[1,2],[1,3],[2,3]] | Output: [2,3]",
                        "test2": "Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]] | Output: [1,4]",
                        "test3": "Input: edges = [[1,2],[2,3],[3,4],[4,5],[2,5]] | Output: [2,5]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] findRedundantConnection(int[][] edges) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Accounts Merge",
                "description": "Given a list of accounts where each account consists of a name and a list of email addresses, merge accounts that have common email addresses. Return the merged account lists in sorted order.",
                "topic": "Graph",
                "subtopic": "Union-Find / DFS",
                "level": "Medium",
                "tags": ["graph", "union find", "dfs"],
                "examples": {
                        "example1": "Input: accounts = [['John', 'johnsmith@mail.com', 'john_newyork@mail.com'], ['John', 'johnsmith@mail.com', 'john00@mail.com'], ['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com']]\nOutput: [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com']]"
                },
                "constraints": {
                        "constraint1": "1 <= accounts.length <= 1000",
                        "constraint2": "2 <= accounts[i].length <= 10",
                        "constraint3": "accounts[i][0] consists of lowercase English letters",
                        "constraint4": "accounts[i][j] (j > 0) is a valid email address"
                },
                "hints": {
                        "hint1": "Treat each email as a node in a graph.",
                        "hint2": "Use Union-Find or DFS to merge accounts."
                },
                "testCases": {
                        "test1": "Input: accounts = [['John', 'johnsmith@mail.com', 'john_newyork@mail.com'], ['John', 'johnsmith@mail.com', 'john00@mail.com'], ['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com']] | Output: [['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com']]",
                        "test2": "Input: accounts = [['Alex', 'alex@mail.com', 'alex@work.com'], ['Alex', 'alex@work.com', 'alex@school.com']] | Output: [['Alex', 'alex@mail.com', 'alex@school.com', 'alex@work.com']]",
                        "test3": "Input: accounts = [['Alice', 'alice@mail.com'], ['Bob', 'bob@mail.com'], ['Alice', 'alice@home.com']] | Output: [['Alice', 'alice@mail.com'], ['Bob', 'bob@mail.com'], ['Alice', 'alice@home.com']]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Evaluate Division",
                "description": "You are given an array of equations where each equation consists of two variables and a value representing their division result. You are also given some queries to evaluate using the given equations. Return the results of the queries.",
                "topic": "Graph",
                "subtopic": "DFS / BFS",
                "level": "Medium",
                "tags": ["graph", "dfs", "bfs", "union find"],
                "examples": {
                        "example1": "Input: equations = [['a', 'b'], ['b', 'c']], values = [2.0, 3.0], queries = [['a', 'c'], ['b', 'a'], ['a', 'e']]\nOutput: [6.0, 0.5, -1.0]"
                },
                "constraints": {
                        "constraint1": "1 <= equations.length <= 20",
                        "constraint2": "equations[i].length == 2",
                        "constraint3": "0.0 < values[i] <= 20.0",
                        "constraint4": "queries[i].length == 2"
                },
                "hints": {
                        "hint1": "Build a graph where variables are nodes and division results are edges.",
                        "hint2": "Use DFS or BFS to evaluate the division results."
                },
                "testCases": {
                        "test1": "Input: equations = [['a', 'b'], ['b', 'c']], values = [2.0, 3.0], queries = [['a', 'c'], ['b', 'a'], ['a', 'e']] | Output: [6.0, 0.5, -1.0]",
                        "test2": "Input: equations = [['x', 'y'], ['y', 'z']], values = [4.0, 5.0], queries = [['x', 'z'], ['z', 'x'], ['a', 'b']] | Output: [20.0, 0.05, -1.0]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Minimum Height Trees",
                "description": "A tree is an undirected graph in which any two vertices are connected by exactly one path. Given a tree with n nodes and an edge list, return the roots of the Minimum Height Trees.",
                "topic": "Graph",
                "subtopic": "Topological Sorting / BFS",
                "level": "Medium",
                "tags": ["graph", "topological sorting", "bfs"],
                "examples": {
                        "example1": "Input: n = 4, edges = [[1,0],[1,2],[1,3]]\nOutput: [1]"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 2 * 10^4",
                        "constraint2": "edges.length == n - 1"
                },
                "hints": {
                        "hint1": "Use topological sorting by removing leaves iteratively.",
                        "hint2": "Nodes left at the end will be the roots of Minimum Height Trees."
                },
                "testCases": {
                        "test1": "Input: n = 4, edges = [[1,0],[1,2],[1,3]] | Output: [1]",
                        "test2": "Input: n = 6, edges = [[0,1],[0,2],[0,3],[3,4],[4,5]] | Output: [3,4]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Word Ladder",
                "description": "Given two words (beginWord and endWord), and a dictionary's word list, return the length of the shortest transformation sequence from beginWord to endWord.",
                "topic": "Graph",
                "subtopic": "BFS",
                "level": "Hard",
                "tags": ["graph", "bfs", "string"],
                "examples": {
                        "example1": "Input: beginWord = 'hit', endWord = 'cog', wordList = ['hot','dot','dog','lot','log','cog']\nOutput: 5"
                },
                "constraints": {
                        "constraint1": "1 <= wordList.length <= 5000",
                        "constraint2": "wordList[i] consists of lowercase English letters",
                        "constraint3": "All words are the same length"
                },
                "hints": {
                        "hint1": "Use BFS for shortest path traversal.",
                        "hint2": "Each word is a node in a graph, connected if they differ by one letter."
                },
                "testCases": {
                        "test1": "Input: beginWord = 'hit', endWord = 'cog', wordList = ['hot','dot','dog','lot','log','cog'] | Output: 5",
                        "test2": "Input: beginWord = 'hit', endWord = 'cog', wordList = ['hot','dot','dog','lot','log'] | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Path with Minimum Effort",
                "description": "Given a 2D grid of heights, find a path from the top-left to the bottom-right that minimizes the maximum absolute difference between adjacent cells in the path.",
                "topic": "Graph",
                "subtopic": "Dijkstra's Algorithm",
                "level": "Medium",
                "tags": ["graph", "dijkstra", "binary search"],
                "examples": {
                        "example1": "Input: heights = [[1,2,2],[3,8,2],[5,3,5]]\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "1 <= heights.length, heights[0].length <= 100",
                        "constraint2": "0 <= heights[i][j] <= 10^6"
                },
                "hints": {
                        "hint1": "Use Dijkstra’s Algorithm to track the minimum effort required.",
                        "hint2": "A binary search on effort can help optimize the approach."
                },
                "testCases": {
                        "test1": "Input: heights = [[1,2,2],[3,8,2],[5,3,5]] | Output: 2",
                        "test2": "Input: heights = [[1,2,3],[3,8,4],[5,3,5]] | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int minimumEffortPath(int[][] heights) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def minimumEffortPath(self, heights: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumEffortPath(vector<vector<int>>& heights) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Network Delay Time",
                "description": "There are n network nodes labeled from 1 to n. Given a list of travel times as directed edges and a starting node k, return the time it takes for all nodes to receive the signal.",
                "topic": "Graph",
                "subtopic": "Dijkstra’s Algorithm",
                "level": "Medium",
                "tags": ["graph", "dijkstra", "bellman-ford"],
                "examples": {
                        "example1": "Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 100",
                        "constraint2": "1 <= times.length <= 6000",
                        "constraint3": "times[i] = [ui, vi, wi] where 1 <= ui, vi <= n and 1 <= wi <= 100"
                },
                "hints": {
                        "hint1": "Use Dijkstra’s Algorithm to find the shortest paths.",
                        "hint2": "A priority queue (min heap) can optimize traversal."
                },
                "testCases": {
                        "test1": "Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 | Output: 2",
                        "test2": "Input: times = [[1,2,1]], n = 2, k = 1 | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int networkDelayTime(int[][] times, int n, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Reconstruct Itinerary",
                "description": "Given a list of airline tickets represented by pairs of departure and arrival airports, reconstruct the itinerary in lexical order starting from 'JFK'.",
                "topic": "Graph",
                "subtopic": "Eulerian Path",
                "level": "Hard",
                "tags": ["graph", "dfs", "backtracking"],
                "examples": {
                        "example1": "Input: tickets = [['MUC', 'LHR'], ['JFK', 'MUC'], ['LHR', 'SFO'], ['SFO', 'JFK']]\nOutput: ['JFK', 'MUC', 'LHR', 'SFO', 'JFK']"
                },
                "constraints": {
                        "constraint1": "1 <= tickets.length <= 300",
                        "constraint2": "tickets[i].length == 2",
                        "constraint3": "tickets[i][0] and tickets[i][1] are valid airport codes"
                },
                "hints": {
                        "hint1": "The problem can be modeled as finding an Eulerian path in a directed graph.",
                        "hint2": "Use Hierholzer’s Algorithm or backtracking to find the correct order."
                },
                "testCases": {
                        "test1": "Input: tickets = [['MUC', 'LHR'], ['JFK', 'MUC'], ['LHR', 'SFO'], ['SFO', 'JFK']] | Output: ['JFK', 'MUC', 'LHR', 'SFO', 'JFK']",
                        "test2": "Input: tickets = [['JFK', 'ATL'], ['ATL', 'JFK'], ['JFK', 'SFO']] | Output: ['JFK', 'ATL', 'JFK', 'SFO']"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Min Cost to Connect All Points",
                "description": "Given an array points representing integer coordinates of points on a 2D plane, return the minimum cost to connect all the points such that each point is connected to at least one other point. The cost of connecting two points is the Manhattan distance between them.",
                "topic": "Graph",
                "subtopic": "Minimum Spanning Tree",
                "level": "Medium",
                "tags": ["graph", "mst", "prim’s algorithm", "kruskal’s algorithm"],
                "examples": {
                        "example1": "Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20"
                },
                "constraints": {
                        "constraint1": "1 <= points.length <= 1000",
                        "constraint2": "-10^6 <= points[i][0], points[i][1] <= 10^6"
                },
                "hints": {
                        "hint1": "This problem can be solved using Minimum Spanning Tree (MST).",
                        "hint2": "Prim's Algorithm or Kruskal's Algorithm can be used."
                },
                "testCases": {
                        "test1": "Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]] | Output: 20",
                        "test2": "Input: points = [[3,12],[-2,5],[-4,1]] | Output: 18"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int minCostConnectPoints(int[][] points) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Swim In Rising Water",
                "description": "You are given an n x n integer matrix grid where each value represents the water level at that point. A swimmer starts at the top-left corner and must reach the bottom-right corner. The swimmer can move up, down, left, or right but cannot enter a square until the water level is at least as high as that square's value. Return the minimum time required for the swimmer to reach the bottom-right corner.",
                "topic": "Graph",
                "subtopic": "Dijkstra’s Algorithm",
                "level": "Hard",
                "tags": ["graph", "dijkstra", "binary search"],
                "examples": {
                        "example1": "Input: grid = [[0,2],[1,3]]\nOutput: 3"
                },
                "constraints": {
                        "constraint1": "2 <= n <= 50",
                        "constraint2": "0 <= grid[i][j] < n^2",
                        "constraint3": "All values in grid are unique"
                },
                "hints": {
                        "hint1": "Consider Dijkstra’s Algorithm for finding the minimum time required.",
                        "hint2": "A binary search approach can also be applied."
                },
                "testCases": {
                        "test1": "Input: grid = [[0,2],[1,3]] | Output: 3",
                        "test2": "Input: grid = [[0,1,2],[3,4,5],[6,7,8]] | Output: 8"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int swimInWater(int[][] grid) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int swimInWater(vector<vector<int>>& grid) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Alien Dictionary",
                "description": "There is a new alien language that uses the same letters as the English alphabet but in a different order. Given a sorted dictionary of words in the alien language, return a string representing the order of the letters. If no valid order exists, return an empty string.",
                "topic": "Graph",
                "subtopic": "Topological Sorting",
                "level": "Hard",
                "tags": ["graph", "topological sort", "bfs", "dfs"],
                "examples": {
                        "example1": "Input: words = ['wrt', 'wrf', 'er', 'ett', 'rftt']\nOutput: 'wertf'"
                },
                "constraints": {
                        "constraint1": "1 <= words.length <= 100",
                        "constraint2": "1 <= words[i].length <= 100",
                        "constraint3": "words[i] consists of lowercase English letters"
                },
                "hints": {
                        "hint1": "This problem can be modeled as a graph with directed edges.",
                        "hint2": "Topological sorting (BFS or DFS) can help determine the order."
                },
                "testCases": {
                        "test1": "Input: words = ['wrt', 'wrf', 'er', 'ett', 'rftt'] | Output: 'wertf'",
                        "test2": "Input: words = ['z', 'x', 'z'] | Output: ''"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String alienOrder(String[] words) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def alienOrder(self, words: List[str]) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string alienOrder(vector<string>& words) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Cheapest Flights Within K Stops",
                "description": "You are given an integer n representing the number of cities and a 2D array flights where flights[i] = [from, to, price] indicates that there is a flight from city 'from' to city 'to' with a cost of 'price'. You are also given three integers src, dst, and k, where k represents the maximum number of stops. Return the cheapest price from src to dst with at most k stops. If no such route exists, return -1.",
                "topic": "Graph",
                "subtopic": "Shortest Path",
                "level": "Medium",
                "tags": ["graph", "shortest path", "dijkstra", "bfs"],
                "examples": {
                        "example1": "Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200",
                        "example2": "Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 100",
                        "constraint2": "0 <= flights.length <= (n * (n - 1) / 2)",
                        "constraint3": "flights[i].length == 3",
                        "constraint4": "0 <= from, to < n",
                        "constraint5": "from != to",
                        "constraint6": "1 <= price <= 10^4",
                        "constraint7": "0 <= k <= n - 1",
                        "constraint8": "0 <= src, dst < n"
                },
                "hints": {
                        "hint1": "Consider using BFS with a priority queue (Dijkstra's algorithm).",
                        "hint2": "Keep track of stops and avoid unnecessary paths."
                },
                "testCases": {
                        "test1": "Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1 | Output: 200",
                        "test2": "Input: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0 | Output: 500"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Find Critical and Pseudo Critical Edges in Minimum Spanning Tree",
                "description": "You are given a weighted undirected graph with n nodes numbered from 0 to n-1, represented as an array edges where edges[i] = [u, v, weight] denotes an edge between nodes u and v with weight. A critical edge is one that must be included in any Minimum Spanning Tree (MST), while a pseudo-critical edge is one that can be included but is not necessary. Return two lists: one for critical edges and one for pseudo-critical edges.",
                "topic": "Graph",
                "subtopic": "Minimum Spanning Tree",
                "level": "Hard",
                "tags": ["graph", "mst", "kruskal", "union find"],
                "examples": {
                        "example1": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[0,4,2],[1,3,2],[1,4,3]]\nOutput: [[0,1],[2,3,4,5]]"
                },
                "constraints": {
                        "constraint1": "2 <= n <= 100",
                        "constraint2": "1 <= edges.length <= min(200, n * (n - 1) / 2)",
                        "constraint3": "edges[i].length == 3",
                        "constraint4": "0 <= u, v < n",
                        "constraint5": "u != v",
                        "constraint6": "1 <= weight <= 10^4"
                },
                "hints": {
                        "hint1": "Use Kruskal’s Algorithm to find the MST.",
                        "hint2": "Try removing an edge and checking if the MST cost increases."
                },
                "testCases": {
                        "test1": "Input: n = 5, edges = [[0,1,1],[1,2,1],[2,3,1],[3,4,1],[0,4,2],[1,3,2],[1,4,3]] | Output: [[0,1],[2,3,4,5]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Build a Matrix With Conditions",
                "description": "You are given two integer arrays k1 and k2, where k1 represents a set of precedence constraints on rows and k2 represents constraints on columns. Return a matrix that satisfies both sets of conditions.",
                "topic": "Graph",
                "subtopic": "Topological Sorting",
                "level": "Hard",
                "tags": ["graph", "topological sort", "matrix"],
                "examples": {
                        "example1": "Input: k1 = [[1,2],[2,3]], k2 = [[2,1]]\nOutput: [[0,1,2],[0,2,1]]"
                },
                "constraints": {
                        "constraint1": "1 <= k1.length, k2.length <= 100",
                        "constraint2": "1 <= n <= 100",
                        "constraint3": "1 <= k1[i][0], k1[i][1] <= n",
                        "constraint4": "1 <= k2[i][0], k2[i][1] <= n"
                },
                "hints": {
                        "hint1": "This is a topological sorting problem.",
                        "hint2": "Use topological sorting to determine row and column orders separately."
                },
                "testCases": {
                        "test1": "Input: k1 = [[1,2],[2,3]], k2 = [[2,1]] | Output: [[0,1,2],[0,2,1]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[][] buildMatrix(int k, int[][] k1, int[][] k2) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def buildMatrix(self, k: int, k1: List[List[int]], k2: List[List[int]]) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> buildMatrix(int k, vector<vector<int>>& k1, vector<vector<int>>& k2) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Greatest Common Divisor Traversal",
                "description": "You are given an array nums of positive integers. You can traverse from index i to index j if and only if nums[i] and nums[j] share a common divisor greater than 1. Determine if there is a way to traverse from the first element to the last element of nums.",
                "topic": "Graph",
                "subtopic": "Connected Components",
                "level": "Hard",
                "tags": ["graph", "union find", "gcd"],
                "examples": {
                        "example1": "Input: nums = [2,3,6]\nOutput: true",
                        "example2": "Input: nums = [3,9,5]\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^5",
                        "constraint2": "1 <= nums[i] <= 10^5"
                },
                "hints": {
                        "hint1": "Consider treating numbers as nodes in a graph and adding edges based on common divisors.",
                        "hint2": "Use the Union-Find data structure to efficiently group connected components."
                },
                "testCases": {
                        "test1": "Input: nums = [2,3,6] | Output: true",
                        "test2": "Input: nums = [3,9,5] | Output: false",
                        "test3": "Input: nums = [4,7,14] | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean canTraverseAllPairs(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canTraverseAllPairs(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Kth Largest Element in a Stream",
                "description": "Design a class to find the kth largest element in a stream. The class should have a constructor that takes an integer k and an integer array nums, and a method add(int val) that returns the kth largest element in the stream after inserting val.",
                "topic": "Heap",
                "subtopic": "Priority Queue",
                "level": "Medium",
                "tags": ["heap", "priority queue", "design"],
                "examples": {
                        "example1": "Input: k = 3, nums = [4, 5, 8, 2], operations = ['add(3)', 'add(5)', 'add(10)', 'add(9)', 'add(4)']\nOutput: [4, 5, 5, 8, 8]"
                },
                "constraints": {
                        "constraint1": "1 <= k <= 10^4",
                        "constraint2": "0 <= nums.length <= 10^4",
                        "constraint3": "-10^4 <= nums[i] <= 10^4",
                        "constraint4": "-10^4 <= val <= 10^4",
                        "constraint5": "At most 10^4 calls to add()"
                },
                "hints": {
                        "hint1": "Use a min heap of size k to keep track of the kth largest element.",
                        "hint2": "Each call to add should insert an element and maintain the heap size."
                },
                "testCases": {
                        "test1": "Input: k = 3, nums = [4, 5, 8, 2], operations = ['add(3)', 'add(5)', 'add(10)', 'add(9)', 'add(4)'] | Output: [4, 5, 5, 8, 8]",
                        "test2": "Input: k = 1, nums = [], operations = ['add(10)'] | Output: [10]"
                },
                "codeSnippets": {
                        "java": "class KthLargest {\n    public KthLargest(int k, int[] nums) {\n        // Constructor implementation\n    }\n    public int add(int val) {\n        // Write your code here\n    }\n}",
                        "python": "class KthLargest:\n    def __init__(self, k: int, nums: List[int]):\n        # Constructor implementation\n        pass\n    def add(self, val: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass KthLargest {\npublic:\n    KthLargest(int k, vector<int>& nums) {\n        // Constructor implementation\n    }\n    int add(int val) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Last Stone Weight",
                "description": "You are given an array of integers where each element represents a stone's weight. In each round, the two heaviest stones are smashed together. If they have different weights, the heavier stone reduces by the weight of the lighter one. If they have the same weight, both stones are destroyed. The process continues until at most one stone is left. Return the weight of the last remaining stone, or 0 if all stones are destroyed.",
                "topic": "Heap",
                "subtopic": "Priority Queue",
                "level": "Easy",
                "tags": ["heap", "greedy"],
                "examples": {
                        "example1": "Input: stones = [2,7,4,1,8,1]\nOutput: 1",
                        "example2": "Input: stones = [1]\nOutput: 1"
                },
                "constraints": {
                        "constraint1": "1 <= stones.length <= 30",
                        "constraint2": "1 <= stones[i] <= 1000"
                },
                "hints": {
                        "hint1": "Use a max heap to always pick the two largest stones.",
                        "hint2": "Simulate the process of smashing the stones and inserting the new stone back."
                },
                "testCases": {
                        "test1": "Input: stones = [2,7,4,1,8,1] | Output: 1",
                        "test2": "Input: stones = [1] | Output: 1",
                        "test3": "Input: stones = [10,10,10,10] | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int lastStoneWeight(int[] stones) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int lastStoneWeight(vector<int>& stones) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "K Closest Points to Origin",
                "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points is defined as sqrt(x^2 + y^2), but you may use squared distances for optimization.",
                "topic": "Heap",
                "subtopic": "Sorting and Priority Queue",
                "level": "Medium",
                "tags": ["heap", "sorting", "quick select"],
                "examples": {
                        "example1": "Input: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]",
                        "example2": "Input: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]"
                },
                "constraints": {
                        "constraint1": "1 <= k <= points.length <= 10^4",
                        "constraint2": "-10^4 <= xi, yi <= 10^4"
                },
                "hints": {
                        "hint1": "Use a max heap to maintain the k closest points.",
                        "hint2": "Try QuickSelect for an optimal O(n) solution."
                },
                "testCases": {
                        "test1": "Input: points = [[1,3],[-2,2]], k = 1 | Output: [[-2,2]]",
                        "test2": "Input: points = [[3,3],[5,-1],[-2,4]], k = 2 | Output: [[3,3],[-2,4]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[][] kClosest(int[][] points, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Kth Largest Element in an Array",
                "description": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in sorted order, not the kth distinct element.",
                "topic": "Sorting",
                "subtopic": "Heap and QuickSelect",
                "level": "Medium",
                "tags": ["heap", "sorting", "quickselect"],
                "examples": {
                        "example1": "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
                        "example2": "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
                },
                "constraints": {
                        "constraint1": "1 <= k <= nums.length <= 10^5",
                        "constraint2": "-10^4 <= nums[i] <= 10^4"
                },
                "hints": {
                        "hint1": "Use a min heap of size k.",
                        "hint2": "QuickSelect can find the answer in O(n) time on average."
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int findKthLargest(int[] nums, int k) {\n        // Write your code here\n    }\n}"
                }
        },
        {
                "title": "Task Scheduler",
                "description": "You are given an array of tasks where each task is represented by a character. Each task takes one unit of time to complete. You are also given an integer n, which represents the cooldown period between the same tasks. Determine the least number of time units required to execute all tasks.",
                "topic": "Greedy",
                "subtopic": "Heap and Sorting",
                "level": "Medium",
                "tags": ["greedy", "heap", "sorting"],
                "examples": {
                        "example1": "Input: tasks = ['A','A','A','B','B','B'], n = 2\nOutput: 8",
                        "example2": "Input: tasks = ['A','A','A','B','B','B'], n = 0\nOutput: 6"
                },
                "constraints": {
                        "constraint1": "1 <= tasks.length <= 10^4",
                        "constraint2": "tasks[i] is an uppercase English letter",
                        "constraint3": "0 <= n <= 100"
                },
                "hints": {
                        "hint1": "Use a priority queue to always process the most frequent tasks first.",
                        "hint2": "A greedy approach can help minimize the idle time."
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int leastInterval(vector<char>& tasks, int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Single Threaded CPU",
                "description": "You are given an array of tasks where each task[i] = [enqueueTime, processingTime]. The CPU can process only one task at a time. If multiple tasks are available, it will select the shortest processing time. Return the order in which tasks are processed.",
                "topic": "Heap",
                "subtopic": "Priority Queue and Sorting",
                "level": "Hard",
                "tags": ["heap", "greedy", "sorting"],
                "examples": {
                        "example1": "Input: tasks = [[1,2],[2,4],[3,2],[4,1]]\nOutput: [0,2,3,1]",
                        "example2": "Input: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]\nOutput: [4,3,2,0,1]"
                },
                "constraints": {
                        "constraint1": "1 <= tasks.length <= 10^5",
                        "constraint2": "1 <= enqueueTime, processingTime <= 10^9"
                },
                "hints": {
                        "hint1": "Sort the tasks by enqueue time first.",
                        "hint2": "Use a min-heap to always pick the shortest available task."
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] getOrder(int[][] tasks) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Reorganize String",
                "description": "Given a string s, rearrange the characters so that no two adjacent characters are the same. If it is not possible, return an empty string.",
                "topic": "Heap",
                "subtopic": "Greedy and Priority Queue",
                "level": "Medium",
                "tags": ["heap", "greedy", "string"],
                "examples": {
                        "example1": "Input: s = 'aab'\nOutput: 'aba'",
                        "example2": "Input: s = 'aaab'\nOutput: ''"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 500",
                        "constraint2": "s consists of lowercase English letters"
                },
                "hints": {
                        "hint1": "Use a max-heap to always place the most frequent character first.",
                        "hint2": "If the most frequent character occurs more than (n+1)/2 times, return an empty string."
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String reorganizeString(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def reorganizeString(self, s: str) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string reorganizeString(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Design Twitter",
                "description": "Design a Twitter-like system where users can post tweets, follow/unfollow others, and retrieve the 10 most recent tweets in their feed. Implement a class with methods to post a tweet, get the news feed, follow a user, and unfollow a user.",
                "topic": "Design",
                "subtopic": "HashMap and Priority Queue",
                "level": "Medium",
                "tags": ["design", "heap", "hashmap"],
                "examples": {
                        "example1": "Input: operations = ['Twitter', 'postTweet', 'getNewsFeed', 'follow', 'getNewsFeed']\nArgs: [[], [1, 5], [1], [1, 2], [1]]\nOutput: [null, null, [5], null, [5]]"
                },
                "constraints": {
                        "constraint1": "1 <= number of operations <= 10^4",
                        "constraint2": "All user IDs are positive integers"
                },
                "hints": {
                        "hint1": "Use a priority queue to maintain the 10 most recent tweets.",
                        "hint2": "A HashMap can help track followers efficiently."
                },
                "codeSnippets": {
                        "java": "class Twitter {\n    public Twitter() {\n        // Constructor\n    }\n    public void postTweet(int userId, int tweetId) {\n        // Write your code here\n    }\n    public List<Integer> getNewsFeed(int userId) {\n        // Write your code here\n    }\n    public void follow(int followerId, int followeeId) {\n        // Write your code here\n    }\n    public void unfollow(int followerId, int followeeId) {\n        // Write your code here\n    }\n}",
                        "python": "class Twitter:\n    def __init__(self):\n        # Constructor\n        pass\n    def postTweet(self, userId: int, tweetId: int):\n        # Write your code here\n        pass\n    def getNewsFeed(self, userId: int) -> List[int]:\n        # Write your code here\n        pass\n    def follow(self, followerId: int, followeeId: int):\n        # Write your code here\n        pass\n    def unfollow(self, followerId: int, followeeId: int):\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Twitter {\npublic:\n    Twitter() {\n        // Constructor\n    }\n    void postTweet(int userId, int tweetId) {\n        // Write your code here\n    }\n    vector<int> getNewsFeed(int userId) {\n        // Write your code here\n    }\n    void follow(int followerId, int followeeId) {\n        // Write your code here\n    }\n    void unfollow(int followerId, int followeeId) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "IPO",
                "description": "You are given k projects, each with a required capital and a profit. You start with an initial capital W and can only invest in projects with capital ≤ W. Find the maximum capital you can accumulate after completing k projects.",
                "topic": "Heap",
                "subtopic": "Priority Queue and Greedy",
                "level": "Hard",
                "tags": ["heap", "greedy", "priority queue"],
                "examples": {
                        "example1": "Input: k = 2, W = 0, Profits = [1,2,3], Capital = [0,1,1]\nOutput: 4",
                        "example2": "Input: k = 3, W = 0, Profits = [1,2,3], Capital = [0,1,2]\nOutput: 6"
                },
                "constraints": {
                        "constraint1": "1 <= k <= 10^5",
                        "constraint2": "0 <= W <= 10^9",
                        "constraint3": "1 <= Profits.length <= 10^5",
                        "constraint4": "Profits.length == Capital.length"
                },
                "hints": {
                        "hint1": "Use a max-heap to always pick the most profitable available project.",
                        "hint2": "Use a min-heap to track projects that become available as capital increases."
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findMaximizedCapital(self, k: int, W: int, Profits: List[int], Capital: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMaximizedCapital(int k, int W, vector<int>& Profits, vector<int>& Capital) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Find Median From Data Stream",
                "description": "Design a data structure that supports adding numbers and finding the median efficiently. Implement a class with methods to add a number and return the median of the current data stream.",
                "topic": "Heap",
                "subtopic": "Two Heaps",
                "level": "Hard",
                "tags": ["heap", "design", "priority queue"],
                "examples": {
                        "example1": "Input: ['MedianFinder', 'addNum', 'addNum', 'findMedian', 'addNum', 'findMedian']\nArgs: [[], [1], [2], [], [3], []]\nOutput: [null, null, null, 1.5, null, 2.0]"
                },
                "constraints": {
                        "constraint1": "1 <= calls to addNum and findMedian <= 10^5",
                        "constraint2": "-10^5 <= number <= 10^5"
                },
                "hints": {
                        "hint1": "Use two heaps: a max-heap for the left half and a min-heap for the right half.",
                        "hint2": "Ensure the heaps remain balanced after each insertion."
                },
                "codeSnippets": {
                        "java": "class MedianFinder {\n    public MedianFinder() {\n        // Constructor\n    }\n    public void addNum(int num) {\n        // Write your code here\n    }\n    public double findMedian() {\n        // Write your code here\n    }\n}",
                        "python": "class MedianFinder:\n    def __init__(self):\n        # Constructor\n        pass\n    def addNum(self, num: int):\n        # Write your code here\n        pass\n    def findMedian(self) -> float:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass MedianFinder {\npublic:\n    MedianFinder() {\n        // Constructor\n    }\n    void addNum(int num) {\n        // Write your code here\n    }\n    double findMedian() {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Car Pooling",
                "description": "You are given a list of trips where trips[i] = [numPassengers, startLocation, endLocation]. The car can only hold a limited number of passengers at a time. Determine if it is possible to complete all trips.",
                "topic": "Greedy",
                "subtopic": "Prefix Sum and Sorting",
                "level": "Medium",
                "tags": ["greedy", "sorting", "heap"],
                "examples": {
                        "example1": "Input: trips = [[2,1,5],[3,3,7]], capacity = 4\nOutput: false",
                        "example2": "Input: trips = [[2,1,5],[3,3,7]], capacity = 5\nOutput: true"
                },
                "constraints": {
                        "constraint1": "1 <= trips.length <= 1000",
                        "constraint2": "trips[i].length == 3",
                        "constraint3": "0 <= trips[i][1] < trips[i][2] <= 1000"
                },
                "hints": {
                        "hint1": "Use a timeline approach to track changes in passenger count.",
                        "hint2": "A sorted approach helps process events in order."
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean carPooling(int[][] trips, int capacity) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool carPooling(vector<vector<int>>& trips, int capacity) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Longest Happy String",
                "description": "Given three integers a, b, and c, representing the number of 'a', 'b', and 'c' characters available, return any longest possible happy string that can be formed. A string is happy if it does not contain three consecutive identical characters.",
                "topic": "Greedy",
                "subtopic": "Priority Queue",
                "level": "Medium",
                "tags": ["greedy", "heap", "string"],
                "examples": {
                        "example1": "Input: a = 1, b = 1, c = 7\nOutput: 'ccaccbcc'",
                        "example2": "Input: a = 7, b = 1, c = 0\nOutput: 'aabaa'"
                },
                "constraints": {
                        "constraint1": "0 <= a, b, c <= 100",
                        "constraint2": "At least one of a, b, or c is positive"
                },
                "hints": {
                        "hint1": "Use a max-heap to prioritize the character with the highest count.",
                        "hint2": "Ensure no three consecutive characters are the same."
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String longestDiverseString(int a, int b, int c) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def longestDiverseString(self, a: int, b: int, c: int) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestDiverseString(int a, int b, int c) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Insert Interval",
                "description": "Given a set of non-overlapping intervals and a new interval, insert the new interval into the list while maintaining the order and merging overlapping intervals if necessary.",
                "topic": "Intervals",
                "subtopic": "Sorting and Merging",
                "level": "Medium",
                "tags": ["array", "sorting", "intervals"],
                "examples": {
                        "example1": "Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]",
                        "example2": "Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]"
                },
                "constraints": {
                        "constraint1": "0 <= intervals.length <= 10^4",
                        "constraint2": "intervals[i].length == 2",
                        "constraint3": "intervals are sorted by start time"
                },
                "hints": {
                        "hint1": "Use a list to store non-overlapping intervals.",
                        "hint2": "Merge intervals when necessary."
                },
                "testCases": {
                        "test1": "Input: [[1,3],[6,9]], [2,5] | Output: [[1,5],[6,9]]",
                        "test2": "Input: [[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8] | Output: [[1,2],[3,10],[12,16]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Merge Intervals",
                "description": "Given an array of intervals where intervals[i] = [start, end], merge all overlapping intervals and return an array of the non-overlapping intervals that cover all the intervals in the input.",
                "topic": "Intervals",
                "subtopic": "Sorting and Merging",
                "level": "Medium",
                "tags": ["array", "sorting", "intervals"],
                "examples": {
                        "example1": "Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]",
                        "example2": "Input: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]"
                },
                "constraints": {
                        "constraint1": "1 <= intervals.length <= 10^4",
                        "constraint2": "intervals[i].length == 2",
                        "constraint3": "intervals are sorted by start time"
                },
                "hints": {
                        "hint1": "Sort the intervals by start time.",
                        "hint2": "Iterate through and merge overlapping intervals."
                },
                "testCases": {
                        "test1": "Input: [[1,3],[2,6],[8,10],[15,18]] | Output: [[1,6],[8,10],[15,18]]",
                        "test2": "Input: [[1,4],[4,5]] | Output: [[1,5]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Non Overlapping Intervals",
                "description": "Given an array of intervals where intervals[i] = [start, end], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.",
                "topic": "Intervals",
                "subtopic": "Greedy Algorithm",
                "level": "Medium",
                "tags": ["greedy", "sorting", "intervals"],
                "examples": {
                        "example1": "Input: intervals = [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1",
                        "example2": "Input: intervals = [[1,2],[1,2],[1,2]]\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "1 <= intervals.length <= 10^4",
                        "constraint2": "intervals[i].length == 2"
                },
                "hints": {
                        "hint1": "Sort intervals by end time.",
                        "hint2": "Use a greedy approach to remove overlapping intervals."
                },
                "testCases": {
                        "test1": "Input: [[1,2],[2,3],[3,4],[1,3]] | Output: 1",
                        "test2": "Input: [[1,2],[1,2],[1,2]] | Output: 2"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Meeting Rooms",
                "description": "Given an array of meeting time intervals where intervals[i] = [start, end], determine if a person can attend all meetings.",
                "topic": "Intervals",
                "subtopic": "Sorting",
                "level": "Easy",
                "tags": ["array", "sorting", "greedy"],
                "examples": {
                        "example1": "Input: intervals = [[0,30],[5,10],[15,20]]\nOutput: false",
                        "example2": "Input: intervals = [[7,10],[2,4]]\nOutput: true"
                },
                "constraints": {
                        "constraint1": "0 <= intervals.length <= 10^4",
                        "constraint2": "intervals[i].length == 2",
                        "constraint3": "0 <= start < end <= 10^6"
                },
                "hints": {
                        "hint1": "Sort the intervals by start time.",
                        "hint2": "Check if any meeting overlaps with the previous one."
                },
                "testCases": {
                        "test1": "Input: [[0,30],[5,10],[15,20]] | Output: false",
                        "test2": "Input: [[7,10],[2,4]] | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean canAttendMeetings(int[][] intervals) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canAttendMeetings(vector<vector<int>>& intervals) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Meeting Rooms II",
                "description": "Given an array of meeting time intervals where intervals[i] = [start, end], return the minimum number of conference rooms required.",
                "topic": "Intervals",
                "subtopic": "Heap (Priority Queue)",
                "level": "Medium",
                "tags": ["heap", "greedy", "sorting"],
                "examples": {
                        "example1": "Input: intervals = [[0,30],[5,10],[15,20]]\nOutput: 2",
                        "example2": "Input: intervals = [[7,10],[2,4]]\nOutput: 1"
                },
                "constraints": {
                        "constraint1": "1 <= intervals.length <= 10^4",
                        "constraint2": "intervals[i].length == 2",
                        "constraint3": "0 <= start < end <= 10^6"
                },
                "hints": {
                        "hint1": "Sort the intervals by start time.",
                        "hint2": "Use a min-heap to track the end times of meetings."
                },
                "testCases": {
                        "test1": "Input: [[0,30],[5,10],[15,20]] | Output: 2",
                        "test2": "Input: [[7,10],[2,4]] | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int minMeetingRooms(int[][] intervals) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def minMeetingRooms(self, intervals: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minMeetingRooms(vector<vector<int>>& intervals) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Meeting Rooms III",
                "description": "Given n meeting rooms and an array of meeting time intervals where intervals[i] = [start, end], find the room that gets used the most. If multiple rooms have the same usage, return the smallest room number.",
                "topic": "Intervals",
                "subtopic": "Heap (Priority Queue)",
                "level": "Hard",
                "tags": ["heap", "greedy", "sorting"],
                "examples": {
                        "example1": "Input: n = 2, intervals = [[0,10],[1,5],[2,7],[3,4]]\nOutput: 0",
                        "example2": "Input: n = 3, intervals = [[1,20],[2,10],[3,5],[4,9]]\nOutput: 1"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 100",
                        "constraint2": "1 <= intervals.length <= 10^4",
                        "constraint3": "0 <= start < end <= 10^6"
                },
                "hints": {
                        "hint1": "Use a min-heap to track the availability of rooms.",
                        "hint2": "Maintain a count of room usage."
                },
                "testCases": {
                        "test1": "Input: 2, [[0,10],[1,5],[2,7],[3,4]] | Output: 0",
                        "test2": "Input: 3, [[1,20],[2,10],[3,5],[4,9]] | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int mostUsedRoom(int n, int[][] intervals) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def mostUsedRoom(self, n: int, intervals: List[List[int]]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int mostUsedRoom(int n, vector<vector<int>>& intervals) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Minimum Interval to Include Each Query",
                "description": "You are given an array intervals where intervals[i] = [start, end] represents an interval, and an array queries where queries[j] is a query. The answer to a query is the size of the smallest interval that contains queries[j]. If no interval contains queries[j], return -1.",
                "topic": "Intervals",
                "subtopic": "Heap (Priority Queue)",
                "level": "Hard",
                "tags": ["heap", "sorting", "binary search"],
                "examples": {
                        "example1": "Input: intervals = [[1,4],[2,4],[3,6]], queries = [2,3,4,5]\nOutput: [3,3,3,3]",
                        "example2": "Input: intervals = [[2,3],[2,5],[1,8]], queries = [1,4,7]\nOutput: [7,4,7]"
                },
                "constraints": {
                        "constraint1": "1 <= intervals.length <= 10^5",
                        "constraint2": "1 <= queries.length <= 10^5",
                        "constraint3": "1 <= start < end <= 10^6",
                        "constraint4": "1 <= queries[j] <= 10^6"
                },
                "hints": {
                        "hint1": "Sort intervals and queries to efficiently determine the smallest containing interval.",
                        "hint2": "Use a min-heap to track active intervals."
                },
                "testCases": {
                        "test1": "Input: [[1,4],[2,4],[3,6]], [2,3,4,5] | Output: [3,3,3,3]",
                        "test2": "Input: [[2,3],[2,5],[1,8]], [1,4,7] | Output: [7,4,7]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] minInterval(int[][] intervals, int[] queries) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Reverse Linked List",
                "description": "Given the head of a singly linked list, reverse the list and return its head.",
                "topic": "Linked List",
                "subtopic": "Reversal",
                "level": "Easy",
                "tags": ["linked list", "recursion", "iteration"],
                "examples": {
                        "example1": "Input: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]",
                        "example2": "Input: head = [1,2]\nOutput: [2,1]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the list is in the range [0, 5000].",
                        "constraint2": "-5000 <= Node.val <= 5000"
                },
                "hints": {
                        "hint1": "Use iteration or recursion to reverse the links.",
                        "hint2": "Think about how to update the pointers as you traverse the list."
                },
                "testCases": {
                        "test1": "Input: head = [1,2,3,4,5] | Output: [5,4,3,2,1]",
                        "test2": "Input: head = [1,2] | Output: [2,1]",
                        "test3": "Input: head = [] | Output: []"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Merge Two Sorted Lists",
                "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list and return its head.",
                "topic": "Linked List",
                "subtopic": "Merge",
                "level": "Easy",
                "tags": ["linked list", "recursion", "merge"],
                "examples": {
                        "example1": "Input: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]",
                        "example2": "Input: list1 = [], list2 = []\nOutput: []"
                },
                "constraints": {
                        "constraint1": "The number of nodes in both lists is in the range [0, 50].",
                        "constraint2": "-100 <= Node.val <= 100",
                        "constraint3": "Both list1 and list2 are sorted in non-decreasing order."
                },
                "hints": {
                        "hint1": "Use a dummy node to simplify the merging process.",
                        "hint2": "You can solve this recursively or iteratively."
                },
                "testCases": {
                        "test1": "Input: list1 = [1,2,4], list2 = [1,3,4] | Output: [1,1,2,3,4,4]",
                        "test2": "Input: list1 = [], list2 = [] | Output: []",
                        "test3": "Input: list1 = [], list2 = [0] | Output: [0]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Linked List Cycle",
                "description": "Given head, the head of a linked list, determine if the linked list has a cycle. Return true if there is a cycle, otherwise return false.",
                "topic": "Linked List",
                "subtopic": "Cycle Detection",
                "level": "Easy",
                "tags": ["linked list", "two pointers", "cycle detection"],
                "examples": {
                        "example1": "Input: head = [3,2,0,-4], pos = 1\nOutput: true",
                        "example2": "Input: head = [1,2], pos = 0\nOutput: true"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the list is in the range [0, 10^4].",
                        "constraint2": "-10^5 <= Node.val <= 10^5",
                        "constraint3": "pos is -1 or a valid index in the linked list."
                },
                "hints": {
                        "hint1": "Use Floyd’s cycle-finding algorithm (slow and fast pointer).",
                        "hint2": "Think about why a cycle would make a pointer revisit a node."
                },
                "testCases": {
                        "test1": "Input: head = [3,2,0,-4], pos = 1 | Output: true",
                        "test2": "Input: head = [1,2], pos = 0 | Output: true",
                        "test3": "Input: head = [1], pos = -1 | Output: false"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean hasCycle(ListNode head) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def hasCycle(self, head: ListNode) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Reorder List",
                "description": "Given the head of a singly linked list, reorder the list such that the first node is followed by the last node, then the second node by the second-last node, and so on. Modify the list in-place without using extra space.",
                "topic": "Linked List",
                "subtopic": "Reordering",
                "level": "Medium",
                "tags": ["linked list", "two pointers", "rearrange"],
                "examples": {
                        "example1": "Input: head = [1,2,3,4]\nOutput: [1,4,2,3]",
                        "example2": "Input: head = [1,2,3,4,5]\nOutput: [1,5,2,4,3]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the list is in the range [1, 5 * 10^4].",
                        "constraint2": "-10^4 <= Node.val <= 10^4"
                },
                "hints": {
                        "hint1": "Find the middle of the linked list using slow and fast pointers.",
                        "hint2": "Reverse the second half of the list and merge it with the first half."
                },
                "testCases": {
                        "test1": "Input: head = [1,2,3,4] | Output: [1,4,2,3]",
                        "test2": "Input: head = [1,2,3,4,5] | Output: [1,5,2,4,3]",
                        "test3": "Input: head = [1] | Output: [1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public void reorderList(ListNode head) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def reorderList(self, head: ListNode) -> None:\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Remove Nth Node From End of List",
                "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
                "topic": "Linked List",
                "subtopic": "Deletion",
                "level": "Medium",
                "tags": ["linked list", "two pointers", "deletion"],
                "examples": {
                        "example1": "Input: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]",
                        "example2": "Input: head = [1], n = 1\nOutput: []"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the list is in the range [1, 30].",
                        "constraint2": "1 <= n <= list.length",
                        "constraint3": "-100 <= Node.val <= 100"
                },
                "hints": {
                        "hint1": "Use a fast and slow pointer to locate the node to be removed.",
                        "hint2": "Ensure proper handling of edge cases, such as removing the head node."
                },
                "testCases": {
                        "test1": "Input: head = [1,2,3,4,5], n = 2 | Output: [1,2,3,5]",
                        "test2": "Input: head = [1], n = 1 | Output: []",
                        "test3": "Input: head = [1,2], n = 1 | Output: [1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Copy List With Random Pointer",
                "description": "A linked list of length n is given, where each node contains an additional random pointer pointing to any node in the list or null. Return a deep copy of the list.",
                "topic": "Linked List",
                "subtopic": "Deep Copy",
                "level": "Medium",
                "tags": ["linked list", "hashmap", "deep copy"],
                "examples": {
                        "example1": "Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]",
                        "example2": "Input: head = [[1,1],[2,1]]\nOutput: [[1,1],[2,1]]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the list is in the range [0, 1000].",
                        "constraint2": "-10^4 <= Node.val <= 10^4"
                },
                "hints": {
                        "hint1": "Use a hashmap to store mapping from original to copied nodes.",
                        "hint2": "Alternatively, modify the original list temporarily to facilitate copying."
                },
                "testCases": {
                        "test1": "Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]] | Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]",
                        "test2": "Input: head = [[1,1],[2,1]] | Output: [[1,1],[2,1]]",
                        "test3": "Input: head = [] | Output: []"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public Node copyRandomList(Node head) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def copyRandomList(self, head: 'Node') -> 'Node':\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Add Two Numbers",
                "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each node contains a single digit. Add the two numbers and return the sum as a linked list.",
                "topic": "Linked List",
                "subtopic": "Arithmetic Operations",
                "level": "Medium",
                "tags": ["linked list", "math", "recursion"],
                "examples": {
                        "example1": "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]",
                        "example2": "Input: l1 = [0], l2 = [0]\nOutput: [0]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in each linked list is in the range [1, 100].",
                        "constraint2": "0 <= Node.val <= 9",
                        "constraint3": "It is guaranteed that the number does not contain leading zeros, except for the number 0 itself."
                },
                "hints": {
                        "hint1": "Use a dummy head node to simplify the code.",
                        "hint2": "Iterate through both lists simultaneously, keeping track of carry."
                },
                "testCases": {
                        "test1": "Input: l1 = [2,4,3], l2 = [5,6,4] | Output: [7,0,8]",
                        "test2": "Input: l1 = [0], l2 = [0] | Output: [0]",
                        "test3": "Input: l1 = [9,9,9], l2 = [1] | Output: [0,0,0,1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Find The Duplicate Number",
                "description": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive, find and return the duplicate number.",
                "topic": "Array",
                "subtopic": "Cycle Detection",
                "level": "Medium",
                "tags": ["array", "binary search", "two pointers"],
                "examples": {
                        "example1": "Input: nums = [1,3,4,2,2]\nOutput: 2",
                        "example2": "Input: nums = [3,1,3,4,2]\nOutput: 3"
                },
                "constraints": {
                        "constraint1": "1 <= nums.length <= 10^5",
                        "constraint2": "1 <= nums[i] <= n where n = nums.length - 1",
                        "constraint3": "There is only one repeated number in nums."
                },
                "hints": {
                        "hint1": "Use Floyd's Tortoise and Hare (cycle detection) algorithm.",
                        "hint2": "Alternatively, use binary search on the range of values."
                },
                "testCases": {
                        "test1": "Input: nums = [1,3,4,2,2] | Output: 2",
                        "test2": "Input: nums = [3,1,3,4,2] | Output: 3",
                        "test3": "Input: nums = [1,1] | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int findDuplicate(int[] nums) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Reverse Linked List II",
                "description": "Given the head of a singly linked list and two integers left and right where 1 <= left <= right <= n, reverse the nodes of the list from position left to right, and return the reversed list.",
                "topic": "Linked List",
                "subtopic": "Reversal",
                "level": "Medium",
                "tags": ["linked list", "two pointers", "reversal"],
                "examples": {
                        "example1": "Input: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]",
                        "example2": "Input: head = [5], left = 1, right = 1\nOutput: [5]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the list is n.",
                        "constraint2": "1 <= n <= 500",
                        "constraint3": "-500 <= Node.val <= 500",
                        "constraint4": "1 <= left <= right <= n"
                },
                "hints": {
                        "hint1": "Find the left-th node and reverse the sublist up to right-th node.",
                        "hint2": "Keep track of the previous and next pointers carefully."
                },
                "testCases": {
                        "test1": "Input: head = [1,2,3,4,5], left = 2, right = 4 | Output: [1,4,3,2,5]",
                        "test2": "Input: head = [5], left = 1, right = 1 | Output: [5]",
                        "test3": "Input: head = [1,2,3], left = 1, right = 3 | Output: [3,2,1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Design Circular Queue",
                "description": "Design a circular queue data structure that supports the following operations: enqueue, dequeue, front, rear, and checking if the queue is empty or full.",
                "topic": "Data Structures",
                "subtopic": "Queue",
                "level": "Medium",
                "tags": ["queue", "design", "array"],
                "examples": {
                        "example1": "Input: MyCircularQueue circularQueue = new MyCircularQueue(3);\n           circularQueue.enQueue(1);\n           circularQueue.enQueue(2);\n           circularQueue.enQueue(3);\n           circularQueue.enQueue(4);\nOutput: false",
                        "example2": "Input: circularQueue.deQueue();\n           circularQueue.enQueue(4);\n           circularQueue.Rear();\nOutput: 4"
                },
                "constraints": {
                        "constraint1": "1 <= k <= 1000",
                        "constraint2": "0 <= value <= 1000",
                        "constraint3": "Operations will be called at most 10^4 times."
                },
                "hints": {
                        "hint1": "Use a fixed-size array to implement the queue.",
                        "hint2": "Maintain front and rear pointers with modular arithmetic."
                },
                "testCases": {
                        "test1": "Input: MyCircularQueue circularQueue = new MyCircularQueue(3);\n           circularQueue.enQueue(1);\n           circularQueue.enQueue(2);\n           circularQueue.enQueue(3);\n           circularQueue.enQueue(4);\nOutput: false",
                        "test2": "Input: circularQueue.deQueue();\n           circularQueue.enQueue(4);\n           circularQueue.Rear();\nOutput: 4",
                        "test3": "Input: circularQueue.isFull();\nOutput: false"
                },
                "codeSnippets": {
                        "java": "class MyCircularQueue {\n    public MyCircularQueue(int k) {\n        // Constructor\n    }\n    public boolean enQueue(int value) {\n        // Write your code here\n    }\n    public boolean deQueue() {\n        // Write your code here\n    }\n    public int Front() {\n        // Write your code here\n    }\n    public int Rear() {\n        // Write your code here\n    }\n    public boolean isEmpty() {\n        // Write your code here\n    }\n    public boolean isFull() {\n        // Write your code here\n    }\n}",
                        "python": "class MyCircularQueue:\n    def __init__(self, k: int):\n        # Constructor\n        pass\n    def enQueue(self, value: int) -> bool:\n        # Write your code here\n        pass\n    def deQueue(self) -> bool:\n        # Write your code here\n        pass\n    def Front(self) -> int:\n        # Write your code here\n        pass\n    def Rear(self) -> int:\n        # Write your code here\n        pass\n    def isEmpty(self) -> bool:\n        # Write your code here\n        pass\n    def isFull(self) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass MyCircularQueue {\npublic:\n    MyCircularQueue(int k) {\n        // Constructor\n    }\n    bool enQueue(int value) {\n        // Write your code here\n    }\n    bool deQueue() {\n        // Write your code here\n    }\n    int Front() {\n        // Write your code here\n    }\n    int Rear() {\n        // Write your code here\n    }\n    bool isEmpty() {\n        // Write your code here\n    }\n    bool isFull() {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "LFU Cache",
                "description": "Design and implement a Least Frequently Used (LFU) cache with the ability to get and put elements efficiently.",
                "topic": "Data Structures",
                "subtopic": "Cache",
                "level": "Hard",
                "tags": ["hashmap", "linked list", "design"],
                "examples": {
                        "example1": "Input: LFUCache cache = new LFUCache(2);\n           cache.put(1, 1);\n           cache.put(2, 2);\n           cache.get(1);\nOutput: 1",
                        "example2": "Input: cache.put(3, 3);\n           cache.get(2);\nOutput: -1"
                },
                "constraints": {
                        "constraint1": "1 <= capacity <= 10000",
                        "constraint2": "0 <= key, value <= 10^5",
                        "constraint3": "Operations will be called at most 10^5 times."
                },
                "hints": {
                        "hint1": "Use a HashMap and a frequency list.",
                        "hint2": "Maintain the least frequently used elements efficiently."
                },
                "testCases": {
                        "test1": "Input: LFUCache cache = new LFUCache(2);\n           cache.put(1, 1);\n           cache.put(2, 2);\n           cache.get(1);\nOutput: 1",
                        "test2": "Input: cache.put(3, 3);\n           cache.get(2);\nOutput: -1",
                        "test3": "Input: cache.put(4, 4);\n           cache.get(1);\nOutput: -1"
                },
                "codeSnippets": {
                        "java": "class LFUCache {\n    public LFUCache(int capacity) {\n        // Constructor\n    }\n    public int get(int key) {\n        // Write your code here\n    }\n    public void put(int key, int value) {\n        // Write your code here\n    }\n}"
                }
        },
        {
                "title": "LRU Cache",
                "description": "Design a data structure that implements the Least Recently Used (LRU) cache with the ability to get and put elements efficiently.",
                "topic": "Data Structures",
                "subtopic": "Cache",
                "level": "Medium",
                "tags": ["hashmap", "linked list", "design"],
                "examples": {
                        "example1": "Input: LRUCache cache = new LRUCache(2);\n           cache.put(1, 1);\n           cache.put(2, 2);\n           cache.get(1);\nOutput: 1",
                        "example2": "Input: cache.put(3, 3);\n           cache.get(2);\nOutput: -1"
                },
                "constraints": {
                        "constraint1": "1 <= capacity <= 3000",
                        "constraint2": "0 <= key, value <= 10^4",
                        "constraint3": "Operations will be called at most 2 * 10^5 times."
                },
                "hints": {
                        "hint1": "Use a HashMap and a Doubly Linked List.",
                        "hint2": "Maintain the order of recently used elements efficiently."
                },
                "testCases": {
                        "test1": "Input: LRUCache cache = new LRUCache(2);\n           cache.put(1, 1);\n           cache.put(2, 2);\n           cache.get(1);\nOutput: 1",
                        "test2": "Input: cache.put(3, 3);\n           cache.get(2);\nOutput: -1",
                        "test3": "Input: cache.put(4, 4);\n           cache.get(1);\nOutput: -1"
                },
                "codeSnippets": {
                        "java": "class LRUCache {\n    public LRUCache(int capacity) {\n        // Constructor\n    }\n    public int get(int key) {\n        // Write your code here\n    }\n    public void put(int key, int value) {\n        // Write your code here\n    }\n}",
                        "python": "class LRUCache:\n    def __init__(self, capacity: int):\n        # Constructor\n        pass\n    def get(self, key: int) -> int:\n        # Write your code here\n        pass\n    def put(self, key: int, value: int) -> None:\n        # Write your code here\n        pass",
                        "cpp": "#include <unordered_map>\nusing namespace std;\n\nclass LRUCache {\npublic:\n    LRUCache(int capacity) {\n        // Constructor\n    }\n    int get(int key) {\n        // Write your code here\n    }\n    void put(int key, int value) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Merge K Sorted Lists",
                "description": "You are given an array of k linked lists, where each linked list is sorted in ascending order. Merge all the linked lists into one sorted linked list and return it.",
                "topic": "Linked List",
                "subtopic": "Heap/Priority Queue",
                "level": "Hard",
                "tags": ["linked list", "heap", "divide and conquer"],
                "examples": {
                        "example1": "Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]",
                        "example2": "Input: lists = []\nOutput: []"
                },
                "constraints": {
                        "constraint1": "k == lists.length",
                        "constraint2": "0 <= k <= 10^4",
                        "constraint3": "0 <= lists[i].length <= 500",
                        "constraint4": "-10^4 <= lists[i][j] <= 10^4",
                        "constraint5": "lists[i] is sorted in ascending order."
                },
                "hints": {
                        "hint1": "Use a priority queue (min-heap) to efficiently merge lists.",
                        "hint2": "A divide and conquer approach can reduce time complexity."
                },
                "testCases": {
                        "test1": "Input: lists = [[1,4,5],[1,3,4],[2,6]] | Output: [1,1,2,3,4,4,5,6]",
                        "test2": "Input: lists = [] | Output: []",
                        "test3": "Input: lists = [[]] | Output: []"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Reverse Nodes in K Group",
                "description": "Given a linked list, reverse the nodes of the list k at a time and return its modified list. If the number of nodes is not a multiple of k, leave the last group as is.",
                "topic": "Linked List",
                "subtopic": "Recursion/Iteration",
                "level": "Hard",
                "tags": ["linked list", "recursion", "iteration"],
                "examples": {
                        "example1": "Input: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]",
                        "example2": "Input: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the list is n.",
                        "constraint2": "1 <= k <= n <= 5000",
                        "constraint3": "0 <= Node.val <= 1000"
                },
                "hints": {
                        "hint1": "Use recursion or iteration to reverse k nodes at a time.",
                        "hint2": "Check if there are at least k nodes before reversing."
                },
                "testCases": {
                        "test1": "Input: head = [1,2,3,4,5], k = 2 | Output: [2,1,4,3,5]",
                        "test2": "Input: head = [1,2,3,4,5], k = 3 | Output: [3,2,1,4,5]",
                        "test3": "Input: head = [1,2,3,4,5], k = 1 | Output: [1,2,3,4,5]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Baseball Game",
                "description": "You are keeping score for a baseball game with a list of operations, where each operation is either a number, '+', 'D', or 'C'. Return the sum of the scores after processing all operations.",
                "topic": "Stack",
                "subtopic": "Simulation",
                "level": "Easy",
                "tags": ["stack", "simulation", "array"],
                "examples": {
                        "example1": "Input: ops = ['5','2','C','D','+']\nOutput: 30",
                        "example2": "Input: ops = ['5','-2','4','C','D','9','+','+']\nOutput: 27"
                },
                "constraints": {
                        "constraint1": "1 <= ops.length <= 1000",
                        "constraint2": "ops[i] is a valid operation."
                },
                "hints": {
                        "hint1": "Use a stack to keep track of scores.",
                        "hint2": "'C' removes the last valid score, 'D' doubles the last valid score, and '+' sums the last two valid scores."
                },
                "testCases": {
                        "test1": "Input: ['5','2','C','D','+'] | Output: 30",
                        "test2": "Input: ['5','-2','4','C','D','9','+','+'] | Output: 27",
                        "test3": "Input: ['1'] | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int calPoints(String[] ops) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def calPoints(self, ops: List[str]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int calPoints(vector<string>& ops) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Valid Parentheses",
                "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
                "topic": "Stack",
                "subtopic": "String Manipulation",
                "level": "Easy",
                "tags": ["stack", "string"],
                "examples": {
                        "example1": "Input: s = '()'\nOutput: true",
                        "example2": "Input: s = '()[]{}'\nOutput: true",
                        "example3": "Input: s = '(]'\nOutput: false"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 10^4",
                        "constraint2": "s consists of parentheses only."
                },
                "hints": {
                        "hint1": "Use a stack to track open brackets.",
                        "hint2": "Ensure that closing brackets match the most recent open bracket."
                },
                "testCases": {
                        "test1": "Input: '()' | Output: true",
                        "test2": "Input: '()[]{}' | Output: true",
                        "test3": "Input: '(]' | Output: false"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isValid(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isValid(self, s: str) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isValid(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Implement Stack Using Queues",
                "description": "Implement a last-in-first-out (LIFO) stack using only two queues.",
                "topic": "Stack",
                "subtopic": "Queue",
                "level": "Easy",
                "tags": ["stack", "queue", "design"],
                "examples": {
                        "example1": "Input: ['MyStack', 'push', 'push', 'top', 'pop', 'empty']\nOutput: [null, null, null, 2, 2, false]"
                },
                "constraints": {
                        "constraint1": "At most 100 operations will be performed.",
                        "constraint2": "All operations are valid."
                },
                "hints": {
                        "hint1": "Use two queues to simulate a stack.",
                        "hint2": "One queue should always contain all elements in stack order."
                },
                "testCases": {
                        "test1": "Input: ['MyStack', 'push', 'push', 'top', 'pop', 'empty'] | Output: [null, null, null, 2, 2, false]"
                },
                "codeSnippets": {
                        "java": "class MyStack {\n    public MyStack() {\n        // Initialize your data structure here\n    }\n    public void push(int x) {\n        // Write your code here\n    }\n    public int pop() {\n        // Write your code here\n    }\n    public int top() {\n        // Write your code here\n    }\n    public boolean empty() {\n        // Write your code here\n    }\n}",
                        "python": "class MyStack:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n    def push(self, x: int) -> None:\n        # Write your code here\n        pass\n    def pop(self) -> int:\n        # Write your code here\n        pass\n    def top(self) -> int:\n        # Write your code here\n        pass\n    def empty(self) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <queue>\nusing namespace std;\n\nclass MyStack {\npublic:\n    MyStack() {\n        // Initialize your data structure here\n    }\n    void push(int x) {\n        // Write your code here\n    }\n    int pop() {\n        // Write your code here\n    }\n    int top() {\n        // Write your code here\n    }\n    bool empty() {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Implement Queue Using Stacks",
                "description": "Implement a first-in-first-out (FIFO) queue using only two stacks.",
                "topic": "Queue",
                "subtopic": "Stack",
                "level": "Easy",
                "tags": ["queue", "stack", "design"],
                "examples": {
                        "example1": "Input: ['MyQueue', 'push', 'push', 'peek', 'pop', 'empty']\nOutput: [null, null, null, 1, 1, false]"
                },
                "constraints": {
                        "constraint1": "At most 100 operations will be performed.",
                        "constraint2": "All operations are valid."
                },
                "hints": {
                        "hint1": "Use two stacks to simulate a queue.",
                        "hint2": "One stack should hold elements in reverse order."
                },
                "testCases": {
                        "test1": "Input: ['MyQueue', 'push', 'push', 'peek', 'pop', 'empty'] | Output: [null, null, null, 1, 1, false]"
                },
                "codeSnippets": {
                        "java": "class MyQueue {\n    public MyQueue() {\n        // Initialize your data structure here\n    }\n    public void push(int x) {\n        // Write your code here\n    }\n    public int pop() {\n        // Write your code here\n    }\n    public int peek() {\n        // Write your code here\n    }\n    public boolean empty() {\n        // Write your code here\n    }\n}",
                        "python": "class MyQueue:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n    def push(self, x: int) -> None:\n        # Write your code here\n        pass\n    def pop(self) -> int:\n        # Write your code here\n        pass\n    def peek(self) -> int:\n        # Write your code here\n        pass\n    def empty(self) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <stack>\nusing namespace std;\n\nclass MyQueue {\npublic:\n    MyQueue() {\n        // Initialize your data structure here\n    }\n    void push(int x) {\n        // Write your code here\n    }\n    int pop() {\n        // Write your code here\n    }\n    int peek() {\n        // Write your code here\n    }\n    bool empty() {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Min Stack",
                "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
                "topic": "Stack",
                "subtopic": "Design",
                "level": "Medium",
                "tags": ["stack", "design"],
                "examples": {
                        "example1": "Input: ['MinStack', 'push', 'push', 'push', 'getMin', 'pop', 'top', 'getMin']\nOutput: [null, null, null, null, -3, null, 0, -2]"
                },
                "constraints": {
                        "constraint1": "At most 3 * 10^4 calls will be made to push, pop, top, and getMin.",
                        "constraint2": "All operations are valid."
                },
                "hints": {
                        "hint1": "Use an auxiliary stack to keep track of the minimum value.",
                        "hint2": "Each time a value is pushed, also push the minimum value so far."
                },
                "testCases": {
                        "test1": "Input: ['MinStack', 'push', 'push', 'push', 'getMin', 'pop', 'top', 'getMin'] | Output: [null, null, null, null, -3, null, 0, -2]"
                },
                "codeSnippets": {
                        "java": "class MinStack {\n    public MinStack() {\n        // Initialize your data structure here\n    }\n    public void push(int val) {\n        // Write your code here\n    }\n    public void pop() {\n        // Write your code here\n    }\n    public int top() {\n        // Write your code here\n    }\n    public int getMin() {\n        // Write your code here\n    }\n}",
                        "python": "class MinStack:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n    def push(self, val: int) -> None:\n        # Write your code here\n        pass\n    def pop(self) -> None:\n        # Write your code here\n        pass\n    def top(self) -> int:\n        # Write your code here\n        pass\n    def getMin(self) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <stack>\nusing namespace std;\n\nclass MinStack {\npublic:\n    MinStack() {\n        // Initialize your data structure here\n    }\n    void push(int val) {\n        // Write your code here\n    }\n    void pop() {\n        // Write your code here\n    }\n    int top() {\n        // Write your code here\n    }\n    int getMin() {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Generate Parentheses",
                "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
                "topic": "Backtracking",
                "subtopic": "String Generation",
                "level": "Medium",
                "tags": ["backtracking", "string"],
                "examples": {
                        "example1": "Input: n = 3\nOutput: ['((()))', '(()())', '(())()', '()(())', '()()()']",
                        "example2": "Input: n = 1\nOutput: ['()']"
                },
                "constraints": {
                        "constraint1": "1 <= n <= 8",
                        "constraint2": "Each pair of parentheses must be correctly matched."
                },
                "hints": {
                        "hint1": "Use backtracking to build the result recursively.",
                        "hint2": "Track the number of open and close parentheses used."
                },
                "testCases": {
                        "test1": "Input: 3 | Output: ['((()))', '(()())', '(())()', '()(())', '()()()']",
                        "test2": "Input: 1 | Output: ['()']"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Evaluate Reverse Polish Notation",
                "description": "Evaluate the value of an arithmetic expression in Reverse Polish Notation.",
                "topic": "Stack",
                "subtopic": "Evaluation",
                "level": "Medium",
                "tags": ["stack", "math", "evaluation"],
                "examples": {
                        "example1": "Input: tokens = ['2', '1', '+', '3', '*']\nOutput: 9",
                        "example2": "Input: tokens = ['4', '13', '5', '/', '+']\nOutput: 6"
                },
                "constraints": {
                        "constraint1": "1 <= tokens.length <= 10^4",
                        "constraint2": "tokens[i] is either an operand or an operator (+, -, *, /)."
                },
                "hints": {
                        "hint1": "Use a stack to store intermediate results.",
                        "hint2": "When encountering an operator, pop two elements and perform the operation."
                },
                "testCases": {
                        "test1": "Input: ['2', '1', '+', '3', '*'] | Output: 9",
                        "test2": "Input: ['4', '13', '5', '/', '+'] | Output: 6",
                        "test3": "Input: ['10', '6', '9', '3', '/', '-', '*'] | Output: 30"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int evalRPN(String[] tokens) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Asteroid Collision",
                "description": "Given an array of integers representing asteroids in a row, positive meaning moving right and negative meaning moving left, return the state of the asteroids after all collisions.",
                "topic": "Stack",
                "subtopic": "Simulation",
                "level": "Medium",
                "tags": ["stack", "simulation"],
                "examples": {
                        "example1": "Input: asteroids = [5, 10, -5]\nOutput: [5, 10]",
                        "example2": "Input: asteroids = [8, -8]\nOutput: []"
                },
                "constraints": {
                        "constraint1": "2 <= asteroids.length <= 10^4",
                        "constraint2": "-1000 <= asteroids[i] <= 1000, asteroids[i] != 0"
                },
                "hints": {
                        "hint1": "Use a stack to process collisions.",
                        "hint2": "When an asteroid moves left, compare it with the top of the stack."
                },
                "testCases": {
                        "test1": "Input: [5, 10, -5] | Output: [5, 10]",
                        "test2": "Input: [8, -8] | Output: []",
                        "test3": "Input: [10, 2, -5] | Output: [10]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] asteroidCollision(int[] asteroids) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> asteroidCollision(vector<int>& asteroids) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Daily Temperatures",
                "description": "Given a list of daily temperatures, return a list where each element represents the number of days you have to wait for a warmer temperature. If there is no future day with a warmer temperature, return 0 for that day.",
                "topic": "Stack",
                "subtopic": "Monotonic Stack",
                "level": "Medium",
                "tags": ["stack", "monotonic stack"],
                "examples": {
                        "example1": "Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]",
                        "example2": "Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]"
                },
                "constraints": {
                        "constraint1": "1 <= temperatures.length <= 10^5",
                        "constraint2": "30 <= temperatures[i] <= 100"
                },
                "hints": {
                        "hint1": "Use a stack to keep track of indices of temperatures.",
                        "hint2": "If the current temperature is higher than the top of the stack, compute the waiting days."
                },
                "testCases": {
                        "test1": "Input: [73,74,75,71,69,72,76,73] | Output: [1,1,4,2,1,1,0,0]",
                        "test2": "Input: [30,40,50,60] | Output: [1,1,1,0]",
                        "test3": "Input: [30,60,90] | Output: [1,1,0]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Online Stock Span",
                "description": "Design a class that collects daily price quotes for stocks and returns the span of stock's price for the current day. The span is the maximum number of consecutive days where the stock price was less than or equal to the current price.",
                "topic": "Stack",
                "subtopic": "Monotonic Stack",
                "level": "Medium",
                "tags": ["stack", "design", "monotonic stack"],
                "examples": {
                        "example1": "Input: ['StockSpanner', 'next', 'next', 'next', 'next', 'next', 'next', 'next']\n       [[],[100],[80],[60],[70],[60],[75],[85]]\nOutput: [null,1,1,1,2,1,4,6]"
                },
                "constraints": {
                        "constraint1": "1 <= price <= 10^5",
                        "constraint2": "Calls to next() will be made at most 10^4 times."
                },
                "hints": {
                        "hint1": "Use a monotonic decreasing stack to track prices and spans.",
                        "hint2": "Keep track of past prices and their spans in a stack."
                },
                "testCases": {
                        "test1": "Input: ['StockSpanner', 'next', 'next', 'next', 'next', 'next', 'next', 'next'] | Output: [null,1,1,1,2,1,4,6]"
                },
                "codeSnippets": {
                        "java": "class StockSpanner {\n    public StockSpanner() {\n        // Initialize your data structure here\n    }\n    public int next(int price) {\n        // Write your code here\n    }\n}",
                        "python": "class StockSpanner:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n    def next(self, price: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <stack>\nusing namespace std;\n\nclass StockSpanner {\npublic:\n    StockSpanner() {\n        // Initialize your data structure here\n    }\n    int next(int price) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Car Fleet",
                "description": "There are n cars going to the same destination along a one-lane road. Each car i has a position and speed. The destination is target miles away. A car fleet is a group of cars that travel together at the same speed. Return the number of fleets that arrive at the destination.",
                "topic": "Stack",
                "subtopic": "Sorting & Stack",
                "level": "Medium",
                "tags": ["greedy", "sorting", "stack"],
                "examples": {
                        "example1": "Input: target = 12, position = [10, 8, 0, 5, 3], speed = [2, 4, 1, 1, 3]\nOutput: 3",
                        "example2": "Input: target = 10, position = [3], speed = [3]\nOutput: 1"
                },
                "constraints": {
                        "constraint1": "1 <= target <= 10^6",
                        "constraint2": "1 <= position.length == speed.length <= 10^5",
                        "constraint3": "0 <= position[i] < target",
                        "constraint4": "All positions are unique",
                        "constraint5": "1 <= speed[i] <= 10^6"
                },
                "hints": {
                        "hint1": "Sort the cars by starting position descending.",
                        "hint2": "Use a stack to keep track of the fleet formation."
                },
                "testCases": {
                        "test1": "Input: target = 12, position = [10, 8, 0, 5, 3], speed = [2, 4, 1, 1, 3] | Output: 3",
                        "test2": "Input: target = 10, position = [3], speed = [3] | Output: 1",
                        "test3": "Input: target = 15, position = [6, 8, 2], speed = [3, 2, 5] | Output: 2"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int carFleet(int target, int[] position, int[] speed) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Simplify Path",
                "description": "Given a string representing an absolute Unix path, simplify it and return the canonical path.",
                "topic": "Stack",
                "subtopic": "String Manipulation",
                "level": "Medium",
                "tags": ["stack", "string"],
                "examples": {
                        "example1": "Input: path = '/home/'\nOutput: '/home'",
                        "example2": "Input: path = '/../'\nOutput: '/'"
                },
                "constraints": {
                        "constraint1": "1 <= path.length <= 3000",
                        "constraint2": "path consists of English letters, digits, '.', '/', and '_' only.",
                        "constraint3": "path is a valid absolute Unix path"
                },
                "hints": {
                        "hint1": "Use a stack to process path components.",
                        "hint2": "Handle '..' by popping from the stack and ignore '.'"
                },
                "testCases": {
                        "test1": "Input: '/home/' | Output: '/home'",
                        "test2": "Input: '/../' | Output: '/'",
                        "test3": "Input: '/home//foo/' | Output: '/home/foo'"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String simplifyPath(String path) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Decode String",
                "description": "Given an encoded string, return its decoded version. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times.",
                "topic": "Stack",
                "subtopic": "String Manipulation",
                "level": "Medium",
                "tags": ["stack", "string"],
                "examples": {
                        "example1": "Input: s = '3[a]2[bc]'\nOutput: 'aaabcbc'",
                        "example2": "Input: s = '3[a2[c]]'\nOutput: 'accaccacc'"
                },
                "constraints": {
                        "constraint1": "1 <= s.length <= 30",
                        "constraint2": "s consists of lowercase English letters, digits, and square brackets.",
                        "constraint3": "s is a valid encoding string."
                },
                "hints": {
                        "hint1": "Use a stack to keep track of repeated characters and their frequencies.",
                        "hint2": "Process the string character by character and build the final result."
                },
                "testCases": {
                        "test1": "Input: '3[a]2[bc]' | Output: 'aaabcbc'",
                        "test2": "Input: '3[a2[c]]' | Output: 'accaccacc'",
                        "test3": "Input: '2[abc]3[cd]ef' | Output: 'abcabccdcdcdef'"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public String decodeString(String s) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def decodeString(self, s: str) -> str:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Maximum Frequency Stack",
                "description": "Design a stack-like data structure that supports pushing elements to the stack and popping the most frequent element. If there is a tie, pop the most recent element among them.",
                "topic": "Stack",
                "subtopic": "HashMap + Stack",
                "level": "Hard",
                "tags": ["stack", "hashmap", "design"],
                "examples": {
                        "example1": "Input: [\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"], [[], [5], [7], [5], [7], [4], [5], [], [], [], []]\nOutput: [null, null, null, null, null, null, null, 5, 7, 5, 4]",
                        "example2": "Input: [\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"], [[], [1], [2], [2], [1], [], [], [], []]\nOutput: [null, null, null, null, 1, 2, 2, 1]"
                },
                "constraints": {
                        "constraint1": "1 <= val <= 10^9",
                        "constraint2": "At most 2 * 10^4 calls will be made to push and pop"
                },
                "hints": {
                        "hint1": "Use a HashMap to track frequencies of elements.",
                        "hint2": "Use a stack of stacks to track elements with the same frequency."
                },
                "testCases": {
                        "test1": "Input: [\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"], [[], [5], [7], [5], [7], [4], [5], [], [], [], []] | Output: [null, null, null, null, null, null, null, 5, 7, 5, 4]",
                        "test2": "Input: [\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"], [[], [1], [2], [2], [1], [], [], [], []] | Output: [null, null, null, null, 1, 2, 2, 1]"
                },
                "codeSnippets": {
                        "java": "class FreqStack {\n    public FreqStack() {\n        // Write your code here\n    }\n    public void push(int val) {\n        // Write your code here\n    }\n    public int pop() {\n        // Write your code here\n    }\n}",
                        "python": "class FreqStack:\n    def __init__(self):\n        # Write your code here\n        pass\n    def push(self, val: int) -> None:\n        # Write your code here\n        pass\n    def pop(self) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass FreqStack {\npublic:\n    FreqStack() {\n        // Write your code here\n    }\n    void push(int val) {\n        // Write your code here\n    }\n    int pop() {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Largest Rectangle in Histogram",
                "description": "Given an array of integers representing the heights of bars in a histogram, find the largest rectangular area that can be formed in the histogram.",
                "topic": "Stack",
                "subtopic": "Monotonic Stack",
                "level": "Hard",
                "tags": ["stack", "monotonic stack", "array"],
                "examples": {
                        "example1": "Input: heights = [2,1,5,6,2,3]\nOutput: 10",
                        "example2": "Input: heights = [2,4]\nOutput: 4"
                },
                "constraints": {
                        "constraint1": "1 <= heights.length <= 10^5",
                        "constraint2": "0 <= heights[i] <= 10^4"
                },
                "hints": {
                        "hint1": "Use a monotonic increasing stack to track heights.",
                        "hint2": "Calculate the largest rectangle area by iterating through heights and finding the next smaller element."
                },
                "testCases": {
                        "test1": "Input: heights = [2,1,5,6,2,3] | Output: 10",
                        "test2": "Input: heights = [2,4] | Output: 4",
                        "test3": "Input: heights = [1,1,1,1,1] | Output: 5"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Binary Tree Inorder Traversal",
                "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
                "topic": "Tree",
                "subtopic": "Tree Traversal",
                "level": "Easy",
                "tags": ["tree", "depth-first search", "stack"],
                "examples": {
                        "example1": "Input: root = [1,null,2,3]\nOutput: [1,3,2]",
                        "example2": "Input: root = []\nOutput: []"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [0, 100].",
                        "constraint2": "-100 <= Node.val <= 100"
                },
                "hints": {
                        "hint1": "Use a stack to simulate recursion if solving iteratively.",
                        "hint2": "Follow the left-root-right order for inorder traversal."
                },
                "testCases": {
                        "test1": "Input: root = [1,null,2,3] | Output: [1,3,2]",
                        "test2": "Input: root = [] | Output: []",
                        "test3": "Input: root = [1] | Output: [1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Binary Tree Preorder Traversal",
                "description": "Given the root of a binary tree, return the preorder traversal of its nodes' values.",
                "topic": "Binary Tree",
                "subtopic": "Tree Traversal",
                "level": "Easy",
                "tags": ["tree", "depth-first search", "stack"],
                "examples": {
                        "example1": "Input: root = [1,null,2,3]\nOutput: [1,2,3]",
                        "example2": "Input: root = []\nOutput: []"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [0, 100].",
                        "constraint2": "-100 <= Node.val <= 100"
                },
                "hints": {
                        "hint1": "Use a stack to simulate recursion if solving iteratively.",
                        "hint2": "Follow the root-left-right order for preorder traversal."
                },
                "testCases": {
                        "test1": "Input: root = [1,null,2,3] | Output: [1,2,3]",
                        "test2": "Input: root = [] | Output: []",
                        "test3": "Input: root = [1] | Output: [1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Binary Tree Postorder Traversal",
                "description": "Given the root of a binary tree, return the postorder traversal of its nodes' values.",
                "topic": "Binary Tree",
                "subtopic": "Tree Traversal",
                "level": "Easy",
                "tags": ["tree", "depth-first search", "stack"],
                "examples": {
                        "example1": "Input: root = [1,null,2,3]\nOutput: [3,2,1]",
                        "example2": "Input: root = []\nOutput: []"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [0, 100].",
                        "constraint2": "-100 <= Node.val <= 100"
                },
                "hints": {
                        "hint1": "Use a stack to simulate recursion if solving iteratively.",
                        "hint2": "Follow the left-right-root order for postorder traversal."
                },
                "testCases": {
                        "test1": "Input: root = [1,null,2,3] | Output: [3,2,1]",
                        "test2": "Input: root = [] | Output: []",
                        "test3": "Input: root = [1] | Output: [1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def postorderTraversal(self, root: TreeNode) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Invert Binary Tree",
                "description": "Given the root of a binary tree, invert the tree and return its root.",
                "topic": "Binary Tree",
                "subtopic": "Tree Manipulation",
                "level": "Easy",
                "tags": ["tree", "depth-first search", "breadth-first search"],
                "examples": {
                        "example1": "Input: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]",
                        "example2": "Input: root = [2,1,3]\nOutput: [2,3,1]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [0, 100].",
                        "constraint2": "-100 <= Node.val <= 100"
                },
                "hints": {
                        "hint1": "Think about how you would swap the left and right subtrees.",
                        "hint2": "Use recursion or an iterative approach with a queue."
                },
                "testCases": {
                        "test1": "Input: root = [4,2,7,1,3,6,9] | Output: [4,7,2,9,6,3,1]",
                        "test2": "Input: root = [2,1,3] | Output: [2,3,1]",
                        "test3": "Input: root = [] | Output: []"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public TreeNode invertTree(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Maximum Depth of Binary Tree",
                "description": "Given the root of a binary tree, return its maximum depth.",
                "topic": "Binary Tree",
                "subtopic": "Tree Traversal",
                "level": "Easy",
                "tags": ["tree", "depth-first search", "breadth-first search"],
                "examples": {
                        "example1": "Input: root = [3,9,20,null,null,15,7]\nOutput: 3",
                        "example2": "Input: root = [1,null,2]\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [0, 10^4].",
                        "constraint2": "-100 <= Node.val <= 100"
                },
                "hints": {
                        "hint1": "Use recursion to find the depth of left and right subtrees.",
                        "hint2": "Consider an iterative approach using a queue for level-order traversal."
                },
                "testCases": {
                        "test1": "Input: root = [3,9,20,null,null,15,7] | Output: 3",
                        "test2": "Input: root = [1,null,2] | Output: 2",
                        "test3": "Input: root = [] | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int maxDepth(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Diameter of Binary Tree",
                "description": "Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree.",
                "topic": "Binary Tree",
                "subtopic": "Tree Traversal",
                "level": "Medium",
                "tags": ["tree", "depth-first search", "recursion"],
                "examples": {
                        "example1": "Input: root = [1,2,3,4,5]\nOutput: 3",
                        "example2": "Input: root = [1,2]\nOutput: 1"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [1, 10^4].",
                        "constraint2": "-100 <= Node.val <= 100"
                },
                "hints": {
                        "hint1": "The diameter at a given node is the sum of the depths of its left and right subtrees.",
                        "hint2": "Use recursion to calculate the depth of each subtree and update the maximum diameter."
                },
                "testCases": {
                        "test1": "Input: root = [1,2,3,4,5] | Output: 3",
                        "test2": "Input: root = [1,2] | Output: 1",
                        "test3": "Input: root = [1] | Output: 0"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int diameterOfBinaryTree(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int diameterOfBinaryTree(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Balanced Binary Tree",
                "description": "Given a binary tree, determine if it is height-balanced. A binary tree is balanced if the depth of the two subtrees of every node never differs by more than one.",
                "topic": "Binary Tree",
                "subtopic": "Tree Depth",
                "level": "Easy",
                "tags": ["tree", "depth-first search", "recursion"],
                "examples": {
                        "example1": "Input: root = [3,9,20,null,null,15,7]\nOutput: true",
                        "example2": "Input: root = [1,2,2,3,3,null,null,4,4]\nOutput: false"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [0, 5000].",
                        "constraint2": "-10^4 <= Node.val <= 10^4"
                },
                "hints": {
                        "hint1": "Recursively check if the left and right subtrees are balanced.",
                        "hint2": "Use a helper function to calculate the depth and balance condition together."
                },
                "testCases": {
                        "test1": "Input: root = [3,9,20,null,null,15,7] | Output: true",
                        "test2": "Input: root = [1,2,2,3,3,null,null,4,4] | Output: false",
                        "test3": "Input: root = [] | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isBalanced(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Same Tree",
                "description": "Given the roots of two binary trees, p and q, determine if they are the same. Two binary trees are the same if they have the same structure and node values.",
                "topic": "Binary Tree",
                "subtopic": "Tree Comparison",
                "level": "Easy",
                "tags": ["tree", "recursion", "depth-first search"],
                "examples": {
                        "example1": "Input: p = [1,2,3], q = [1,2,3]\nOutput: true",
                        "example2": "Input: p = [1,2], q = [1,null,2]\nOutput: false"
                },
                "constraints": {
                        "constraint1": "The number of nodes in both trees is in the range [0, 100].",
                        "constraint2": "-10^4 <= Node.val <= 10^4"
                },
                "hints": {
                        "hint1": "Use recursion to traverse both trees simultaneously.",
                        "hint2": "Check both structure and values at each node."
                },
                "testCases": {
                        "test1": "Input: p = [1,2,3], q = [1,2,3] | Output: true",
                        "test2": "Input: p = [1,2], q = [1,null,2] | Output: false",
                        "test3": "Input: p = [], q = [] | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Subtree of Another Tree",
                "description": "Given the roots of two binary trees, root and subRoot, determine if subRoot is a subtree of root. A subtree of a binary tree is a tree that consists of a node in root and all of its descendants.",
                "topic": "Binary Tree",
                "subtopic": "Tree Substructure",
                "level": "Medium",
                "tags": ["tree", "depth-first search", "recursion"],
                "examples": {
                        "example1": "Input: root = [3,4,5,1,2], subRoot = [4,1,2]\nOutput: true",
                        "example2": "Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\nOutput: false"
                },
                "constraints": {
                        "constraint1": "The number of nodes in root is in the range [1, 2000].",
                        "constraint2": "The number of nodes in subRoot is in the range [1, 1000].",
                        "constraint3": "-10^4 <= Node.val <= 10^4"
                },
                "hints": {
                        "hint1": "Recursively check if the current node in root matches subRoot.",
                        "hint2": "Use a helper function to determine if two trees are identical."
                },
                "testCases": {
                        "test1": "Input: root = [3,4,5,1,2], subRoot = [4,1,2] | Output: true",
                        "test2": "Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] | Output: false",
                        "test3": "Input: root = [1], subRoot = [1] | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isSubtree(TreeNode* root, TreeNode* subRoot) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Lowest Common Ancestor of a Binary Search Tree",
                "description": "Given a Binary Search Tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. The lowest common ancestor is defined as the lowest node in the tree that has both nodes as descendants.",
                "topic": "Binary Search Tree",
                "subtopic": "Tree Traversal",
                "level": "Medium",
                "tags": ["tree", "binary search tree", "recursion"],
                "examples": {
                        "example1": "Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6",
                        "example2": "Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [2, 100000].",
                        "constraint2": "-10^9 <= Node.val <= 10^9",
                        "constraint3": "All Node values are unique."
                },
                "hints": {
                        "hint1": "Utilize BST properties where left child < root < right child.",
                        "hint2": "Traverse the tree from the root and find the split point where p and q diverge."
                },
                "testCases": {
                        "test1": "Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 | Output: 6",
                        "test2": "Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 | Output: 2",
                        "test3": "Input: root = [2,1], p = 2, q = 1 | Output: 2"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Insert into a Binary Search Tree",
                "description": "Given the root of a Binary Search Tree (BST) and a value to insert into the tree, insert the value into the BST and return the root of the modified tree.",
                "topic": "Binary Search Tree",
                "subtopic": "Insertion",
                "level": "Medium",
                "tags": ["tree", "binary search tree", "recursion"],
                "examples": {
                        "example1": "Input: root = [4,2,7,1,3], val = 5\nOutput: [4,2,7,1,3,5]",
                        "example2": "Input: root = [40,20,60,10,30,50,70], val = 25\nOutput: [40,20,60,10,30,50,70,null,null,25]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [0, 10^4].",
                        "constraint2": "-10^8 <= Node.val <= 10^8",
                        "constraint3": "The new value does not exist in the original BST."
                },
                "hints": {
                        "hint1": "Use BST properties where left child < root < right child.",
                        "hint2": "Recursively find the correct insertion point and place the new node."
                },
                "testCases": {
                        "test1": "Input: root = [4,2,7,1,3], val = 5 | Output: [4,2,7,1,3,5]",
                        "test2": "Input: root = [], val = 1 | Output: [1]",
                        "test3": "Input: root = [5,3,6,2,4,null,8], val = 7 | Output: [5,3,6,2,4,7,8]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Delete Node in a BST",
                "description": "Given the root of a Binary Search Tree (BST) and a key to delete, remove the node with the given key and return the new root of the BST. Ensure the tree remains a valid BST after deletion.",
                "topic": "Binary Search Tree",
                "subtopic": "Deletion",
                "level": "Medium",
                "tags": ["tree", "binary search tree", "recursion"],
                "examples": {
                        "example1": "Input: root = [5,3,6,2,4,null,7], key = 3\nOutput: [5,4,6,2,null,null,7]",
                        "example2": "Input: root = [5,3,6,2,4,null,7], key = 0\nOutput: [5,3,6,2,4,null,7]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [0, 10^4].",
                        "constraint2": "-10^8 <= Node.val <= 10^8"
                },
                "hints": {
                        "hint1": "Find the node first, then adjust the tree structure accordingly.",
                        "hint2": "Consider three cases: node is a leaf, node has one child, node has two children."
                },
                "testCases": {
                        "test1": "Input: root = [5,3,6,2,4,null,7], key = 3 | Output: [5,4,6,2,null,null,7]",
                        "test2": "Input: root = [5,3,6,2,4,null,7], key = 0 | Output: [5,3,6,2,4,null,7]",
                        "test3": "Input: root = [], key = 0 | Output: []"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Binary Tree Level Order Traversal",
                "description": "Given the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).",
                "topic": "Tree",
                "subtopic": "Level Order Traversal",
                "level": "Medium",
                "tags": ["tree", "bfs"],
                "examples": {
                        "example1": "Input: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]",
                        "example2": "Input: root = [1]\nOutput: [[1]]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [0, 2000].",
                        "constraint2": "-1000 <= Node.val <= 1000"
                },
                "hints": {
                        "hint1": "Use a queue to process nodes level by level.",
                        "hint2": "Store nodes of the next level before processing the current level."
                },
                "testCases": {
                        "test1": "Input: root = [3,9,20,null,null,15,7] | Output: [[3],[9,20],[15,7]]",
                        "test2": "Input: root = [1] | Output: [[1]]",
                        "test3": "Input: root = [] | Output: []"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Binary Tree Right Side View",
                "description": "Given the root of a binary tree, imagine yourself standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom.",
                "topic": "Tree",
                "subtopic": "View Traversal",
                "level": "Medium",
                "tags": ["tree", "dfs", "bfs"],
                "examples": {
                        "example1": "Input: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]",
                        "example2": "Input: root = [1,null,3]\nOutput: [1,3]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [0, 100].",
                        "constraint2": "-100 <= Node.val <= 100"
                },
                "hints": {
                        "hint1": "Try using level order traversal with a queue.",
                        "hint2": "At each level, track the rightmost node."
                },
                "testCases": {
                        "test1": "Input: root = [1,2,3,null,5,null,4] | Output: [1,3,4]",
                        "test2": "Input: root = [1,null,3] | Output: [1,3]",
                        "test3": "Input: root = [] | Output: []"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def rightSideView(self, root: TreeNode) -> List[int]:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Construct Quad Tree",
                "description": "Given a n x n binary grid, construct a Quad-Tree representing the grid. The value of each cell in the grid is either 0 or 1. A Quad-Tree is a tree data structure where each internal node has exactly four children and each leaf node represents a uniform subregion.",
                "topic": "Tree",
                "subtopic": "Divide and Conquer",
                "level": "Medium",
                "tags": ["tree", "divide and conquer"],
                "examples": {
                        "example1": "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0]]",
                        "example2": "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[1,1]]"
                },
                "constraints": {
                        "constraint1": "n == grid.length == grid[i].length",
                        "constraint2": "n is a power of 2.",
                        "constraint3": "1 <= n <= 64"
                },
                "hints": {
                        "hint1": "Use recursion to divide the grid into four quadrants.",
                        "hint2": "If all values in a quadrant are the same, represent it as a leaf node."
                },
                "testCases": {
                        "test1": "Input: grid = [[0,1],[1,0]] | Output: [[0,1],[1,0]]",
                        "test2": "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]] | Output: [[1,1]]",
                        "test3": "Input: grid = [[1]] | Output: [[1]]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public Node construct(int[][] grid) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    Node* construct(vector<vector<int>>& grid) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Count Good Nodes in Binary Tree",
                "description": "Given the root of a binary tree, a node X is considered 'good' if on the path from the root to X, there are no nodes with a value greater than X. Return the number of good nodes in the tree.",
                "topic": "Tree",
                "subtopic": "DFS",
                "level": "Medium",
                "tags": ["tree", "dfs"],
                "examples": {
                        "example1": "Input: root = [3,1,4,3,null,1,5]\nOutput: 4",
                        "example2": "Input: root = [3,3,null,4,2]\nOutput: 3"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [1, 10^4].",
                        "constraint2": "-10^4 <= Node.val <= 10^4"
                },
                "hints": {
                        "hint1": "Use depth-first search to traverse the tree.",
                        "hint2": "Keep track of the maximum value encountered on the path."
                },
                "testCases": {
                        "test1": "Input: root = [3,1,4,3,null,1,5] | Output: 4",
                        "test2": "Input: root = [3,3,null,4,2] | Output: 3",
                        "test3": "Input: root = [1] | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int goodNodes(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int goodNodes(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Validate Binary Search Tree",
                "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A BST is valid if every node's left subtree contains only nodes with values less than the node's value, and every node's right subtree contains only nodes with values greater than the node's value.",
                "topic": "Tree",
                "subtopic": "Binary Search Tree",
                "level": "Medium",
                "tags": ["tree", "bst", "dfs"],
                "examples": {
                        "example1": "Input: root = [2,1,3]\nOutput: true",
                        "example2": "Input: root = [5,1,4,null,null,3,6]\nOutput: false"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [1, 10^4].",
                        "constraint2": "-2^31 <= Node.val <= 2^31 - 1"
                },
                "hints": {
                        "hint1": "Use recursive traversal to verify BST conditions.",
                        "hint2": "Maintain upper and lower bounds for node values."
                },
                "testCases": {
                        "test1": "Input: root = [2,1,3] | Output: true",
                        "test2": "Input: root = [5,1,4,null,null,3,6] | Output: false",
                        "test3": "Input: root = [1] | Output: true"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public boolean isValidBST(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Kth Smallest Element in a BST",
                "description": "Given the root of a binary search tree (BST) and an integer k, return the kth smallest element in the BST.",
                "topic": "Tree",
                "subtopic": "Binary Search Tree",
                "level": "Medium",
                "tags": ["tree", "bst", "inorder traversal"],
                "examples": {
                        "example1": "Input: root = [3,1,4,null,2], k = 1\nOutput: 1",
                        "example2": "Input: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [1, 10^4].",
                        "constraint2": "0 <= k <= number of nodes"
                },
                "hints": {
                        "hint1": "Use an in-order traversal to find the kth smallest element.",
                        "hint2": "In-order traversal of a BST results in sorted values."
                },
                "testCases": {
                        "test1": "Input: root = [3,1,4,null,2], k = 1 | Output: 1",
                        "test2": "Input: root = [5,3,6,2,4,null,null,1], k = 3 | Output: 3",
                        "test3": "Input: root = [1], k = 1 | Output: 1"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Construct Binary Tree From Preorder And Inorder Traversal",
                "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
                "topic": "Tree",
                "subtopic": "Binary Tree Construction",
                "level": "Medium",
                "tags": ["tree", "dfs", "recursion"],
                "examples": {
                        "example1": "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]",
                        "example2": "Input: preorder = [-1], inorder = [-1]\nOutput: [-1]"
                },
                "constraints": {
                        "constraint1": "1 <= preorder.length <= 3000",
                        "constraint2": "inorder.length == preorder.length",
                        "constraint3": "-3000 <= preorder[i], inorder[i] <= 3000",
                        "constraint4": "preorder and inorder consist of unique values.",
                        "constraint5": "It is guaranteed that preorder and inorder are valid traversal sequences of the same binary tree."
                },
                "hints": {
                        "hint1": "The first element of preorder is always the root of the tree.",
                        "hint2": "Find the root in inorder to determine the left and right subtrees."
                },
                "testCases": {
                        "test1": "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] | Output: [3,9,20,null,null,15,7]",
                        "test2": "Input: preorder = [-1], inorder = [-1] | Output: [-1]",
                        "test3": "Input: preorder = [1,2,3], inorder = [2,1,3] | Output: [1,2,3]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "House Robber III",
                "description": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the 'root'. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. If two directly-linked houses were robbed on the same night, the police will be alerted. Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.",
                "topic": "Dynamic Programming",
                "subtopic": "Tree DP",
                "level": "Medium",
                "tags": ["tree", "dynamic programming", "dfs"],
                "examples": {
                        "example1": "Input: root = [3,2,3,null,3,null,1]\nOutput: 7",
                        "example2": "Input: root = [3,4,5,1,3,null,1]\nOutput: 9"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [1, 10^4].",
                        "constraint2": "0 <= Node.val <= 10^4"
                },
                "hints": {
                        "hint1": "Use dynamic programming to keep track of two states: including and excluding a node.",
                        "hint2": "Use depth-first search to traverse the tree while maintaining the two states."
                },
                "testCases": {
                        "test1": "Input: root = [3,2,3,null,3,null,1] | Output: 7",
                        "test2": "Input: root = [3,4,5,1,3,null,1] | Output: 9",
                        "test3": "Input: root = [4] | Output: 4"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int rob(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def rob(self, root: TreeNode) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int rob(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Delete Leaves With a Given Value",
                "description": "Given a binary tree root and an integer target, delete all the leaf nodes with the value target. If, after deleting a leaf node with value target, its parent node becomes a leaf and also has the value target, then it should also be deleted. Repeat this process until there are no more nodes to be deleted.",
                "topic": "Tree",
                "subtopic": "Tree Modification",
                "level": "Medium",
                "tags": ["tree", "recursion"],
                "examples": {
                        "example1": "Input: root = [1,2,3,2,null,2,4], target = 2\nOutput: [1,null,3,null,4]",
                        "example2": "Input: root = [1,3,3,3,2], target = 3\nOutput: [1,3,null,null,2]"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [1, 3000].",
                        "constraint2": "1 <= Node.val, target <= 1000"
                },
                "hints": {
                        "hint1": "Use recursion to process leaves first.",
                        "hint2": "Modify the tree in a postorder manner to handle cascaded deletions."
                },
                "testCases": {
                        "test1": "Input: root = [1,2,3,2,null,2,4], target = 2 | Output: [1,null,3,null,4]",
                        "test2": "Input: root = [1,3,3,3,2], target = 3 | Output: [1,3,null,null,2]",
                        "test3": "Input: root = [1,2,null,2,null,2], target = 2 | Output: [1]"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public TreeNode removeLeafNodes(TreeNode root, int target) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def removeLeafNodes(self, root: TreeNode, target: int) -> TreeNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    TreeNode* removeLeafNodes(TreeNode* root, int target) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Binary Tree Maximum Path Sum",
                "description": "Given the root of a binary tree, return the maximum path sum of any non-empty path. A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. The path sum of a path is the sum of the node values in the path.",
                "topic": "Tree",
                "subtopic": "Binary Tree Path Sum",
                "level": "Hard",
                "tags": ["tree", "dfs", "recursion", "dynamic programming"],
                "examples": {
                        "example1": "Input: root = [1,2,3]\nOutput: 6",
                        "example2": "Input: root = [-10,9,20,null,null,15,7]\nOutput: 42"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [1, 3 * 10^4].",
                        "constraint2": "-1000 <= Node.val <= 1000"
                },
                "hints": {
                        "hint1": "Use a recursive function to compute the maximum sum for each subtree.",
                        "hint2": "Keep track of the maximum sum encountered so far while traversing the tree."
                },
                "testCases": {
                        "test1": "Input: root = [1,2,3] | Output: 6",
                        "test2": "Input: root = [-10,9,20,null,null,15,7] | Output: 42",
                        "test3": "Input: root = [2,-1] | Output: 2"
                },
                "codeSnippets": {
                        "java": "class Solution {\n    public int maxPathSum(TreeNode root) {\n        // Write your code here\n    }\n}",
                        "python": "class Solution:\n    def maxPathSum(self, root: TreeNode) -> int:\n        # Write your code here\n        pass",
                        "cpp": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        // Write your code here\n    }\n};"
                }
        },
        {
                "title": "Serialize And Deserialize Binary Tree",
                "description": "Serialization is the process of converting a data structure into a format that can be stored or transmitted and then reconstructed later. Given the root of a binary tree, implement both serialize and deserialize functions. The serialized string should be able to be deserialized back to the original tree.",
                "topic": "Tree",
                "subtopic": "Binary Tree Serialization",
                "level": "Hard",
                "tags": ["tree", "design", "bfs", "dfs"],
                "examples": {
                        "example1": "Input: root = [1,2,3,null,null,4,5]\nOutput: '[1,2,3,null,null,4,5]'",
                        "example2": "Input: root = []\nOutput: '[]'"
                },
                "constraints": {
                        "constraint1": "The number of nodes in the tree is in the range [0, 10^4].",
                        "constraint2": "-1000 <= Node.val <= 1000"
                },
                "hints": {
                        "hint1": "Use a level-order traversal for serialization.",
                        "hint2": "Use a queue to help reconstruct the tree during deserialization."
                },
                "testCases": {
                        "test1": "Input: root = [1,2,3,null,null,4,5] | Output: '[1,2,3,null,null,4,5]'",
                        "test2": "Input: root = [] | Output: '[]'",
                        "test3": "Input: root = [5,3,7,2,4,6,8] | Output: '[5,3,7,2,4,6,8]'"
                },
                "codeSnippets": {
                        "java": "class Codec {\n    public String serialize(TreeNode root) {\n        // Write your code here\n    }\n    public TreeNode deserialize(String data) {\n        // Write your code here\n    }\n}",
                        "python": "class Codec:\n    def serialize(self, root: TreeNode) -> str:\n        # Write your code here\n        pass\n    def deserialize(self, data: str) -> TreeNode:\n        # Write your code here\n        pass",
                        "cpp": "#include <string>\nusing namespace std;\n\nclass Codec {\npublic:\n    string serialize(TreeNode* root) {\n        // Write your code here\n    }\n    TreeNode* deserialize(string data) {\n        // Write your code here\n    }\n};"
                }
        }
]
